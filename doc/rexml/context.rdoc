== Context

Notes:
- All code on this page presupposes that the following has been executed:

    require 'rexml/document'
    include REXML

- For convenience, examples on this page use +Document.new+, not +Element.new+.
  This is completely valid, because \Document is a subclass of \Element.

The context for an element is a hash of processing directives
that influence the way \XML is read, stored, and written.
The context entries are:

- +:respect_whitespace+: controls treatment of whitespace.
- +:compress_whitespace+: determines whether whitespace is compressed.
- +:ignore_whitespace_nodes+: determines whether whitespace-only nodes are to be ignored.
- +:raw+: controls treatment of special characters and entities.

The default context for a new element is <tt>{}</tt>.
You can set the context at element-creation time:

  d = Document.new('', {compress_whitespace: :all, raw: :all})
  d.context # => {:compress_whitespace=>:all, :raw=>:all}

You can reset the entire context by assigning a new hash:

  d.context = {ignore_whitespace_nodes: :all}
  d.context # => {:ignore_whitespace_nodes=>:all}

Or you can create or modify an individual entry:

  d.context[:raw] = :all
  d.context # => {:ignore_whitespace_nodes=>:all, :raw=>:all}

=== +:respect_whitespace+

Affects: +Element.new+, +Element.text=+:

By default, all parsed whitespace is respected (that is, stored whitespace not compressed):

  xml_string = '<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>'
  d = Document.new(xml_string)
  d.to_s # => "<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>"

Use +:respect_whitespace+ with an array of element names
to specify the elements that _are_ to have their whitespace respected;
other elements' whitespace, and whitespace between elements, will be compressed.

In this example: +foo+ and +baz+ will have their whitespace respected;
+bar+ and the space between elements will have their whitespace compressed:

  d = Document.new(xml_string, {respect_whitespace: ['foo', 'baz']})
  d.to_s # => "<root><foo>a   b</foo> <bar>c d</bar> <baz>e   f</baz></root>"
  bar = d.root[2] # => <bar> ... </>
  bar.text = 'X   Y'
  d.to_s # => "<root><foo>a   b</foo> <bar>X Y</bar> <baz>e   f</baz></root>"

=== +:compress_whitespace+

Affects: +Element.new+, +Element.text=+:

Use <tt>compress_whitespace: :all</tt>
to compress whitespace both within and between elements:

  xml_string = '<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>'
  d = Document.new(xml_string, {compress_whitespace: :all})
  d.to_s # => "<root><foo>a b</foo> <bar>c d</bar> <baz>e f</baz></root>"

Use +:compress_whitespace+ with an array of element names
to compress whitespace in those elements,
but not in other elements nor between elements.

In this example, +foo+ and +baz+ will have their whitespace compressed;
+bar+ and the space between elements will not:

  d = Document.new(xml_string, {compress_whitespace: ['foo', 'baz']})
  d.to_s # => "<root><foo>a b</foo>    <bar>c   d</bar>   <baz>e f</baz></root>"
  foo = d.root[0] # => <foo> ... </>
  foo.text= 'X   Y'
  d.to_s # => "<root><foo>X Y</foo>    <bar>c   d</bar>   <baz>e f</baz></root>"

=== +:ignore_whitespace_nodes+

Affects: +Element.new+:

Use <tt>ignore_whitespace_nodes: :all</tt> to omit all whitespace-only elements.

In this example, +bar+ has a text node, while nodes +foo+ and +baz+ do not:

  xml_string = '<root><foo>   </foo><bar> BAR </bar><baz>   </baz></root>'
  d = Document.new(xml_string, {ignore_whitespace_nodes: :all})
  d.to_s # => "<root><foo> FOO </foo><bar/><baz> BAZ </baz></root>"
  root = d.root
  foo = root[0]   # => <foo/>
  bar = root[1]   # => <bar> ... </>
  baz = root[2]   # => <baz/>
  foo.first.class # => NilClass
  bar.first.class # => REXML::Text
  baz.first.class # => NilClass

Use +:ignore_whitespace_nodes+ with an array of element names
to specify the elements that are to have whitespace nodes ignored.

In this example, +bar+ and +baz+ have text nodes, while node +foo+ does not.

  xml_string = '<root><foo>   </foo><bar> BAR </bar><baz>   </baz></root>'
  d = Document.new(xml_string, {ignore_whitespace_nodes: ['foo']})
  d.to_s # => "<root><foo/><bar> BAR </bar><baz>   </baz></root>"
  root = d.root
  foo = root[0]   # => <foo/>
  bar = root[1]   # => <bar> ... </>
  baz = root[2]   # => <baz> ... </>
  foo.first.class # => NilClass
  bar.first.class # => REXML::Text
  baz.first.class # => REXML::Text

=== +:raw+

By default, entities are converted to characters:

  xml_string = '<root><foo>&amp;</foo><bar>&lt;</bar><baz>&gt;</baz><bat>&quot;</bat></root>'
  d = Document.new(xml_string)
  d.to_s
  root = d.root
  foo = root[0]
  bar = root[1]
  baz = root[2]
  bat = root[3]
  foo.text # => "&"
  bar.text # => "<"
  baz.text # => ">"
  bat.text # => "\""

  root = d.root
  foo = root[0]
  bar = root[1]
  baz = root[2]
  bat = root[3]
  foo.text
  bar.text
  baz.text
  bat.text

  :raw is one of the most mysterious (?) features in REXML.

  :raw isn't used with REXML::Document.new. It's used with REXML::Element#text=, REXML::Element#add_text and REXML::Text#to_s:

  xml_string = '<root><foo>&amp;</foo><bar>&lt;</bar><baz>&gt;</baz><bat>&quot;</bat></root>'
  d = REXML::Document.new(xml_string, {raw: ['foo', 'baz']})
  d.to_s # => "<root><foo>&amp;</foo><bar>&lt;</bar><baz>&gt;</baz><bat>&quot;</bat></root>"
  root = d.root
  foo = root[0]
  bar = root[1]
  baz = root[2]
  bat = root[3]
  foo.children[0].to_s # => "&"
  bar.children[0].to_s # => "<"
  baz.children[0].to_s # => ">"
  bat.children[0].to_s # => "\""
  foo.text = "&amp;"
  foo.children[0].to_s # => "&amp;"
  bar.text = "&lt;"
  bar.children[0].to_s # => "&amp;lt;"

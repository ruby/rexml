var search_data = {"index":{"searchIndex":["rexml","attlistdecl","attribute","attributes","cdata","child","comment","dclonable","dtd","attlistdecl","elementdecl","entitydecl","notationdecl","parser","declaration","doctype","document","element","elementdecl","elements","encoding","entity","entityconst","externalentity","formatters","default","pretty","transitive","functions","iosource","instruction","light","node","namespace","node","notationdecl","output","parent","parseexception","parsers","baseparser","private","lightparser","pullevent","pullparser","sax2parser","streamparser","treeparser","ultralightparser","xpathparser","quickpath","referencewriter","sax2listener","security","source","sourcefactory","streamlistener","text","undefinednamespaceexception","validation","choice","event","interleave","oneormore","optional","ref","relaxng","sequence","state","validationexception","validator","zeroormore","xmldecl","xmltokens","xpath","xpathnode","xpathparser","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<=>()","<=>()","==()","==()","==()","==()","==()","=~()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","[]=()","abbreviate()","add()","add()","add()","add()","add()","add_attribute()","add_attributes()","add_element()","add_element()","add_event_to_arry()","add_event_to_arry()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_namespace()","add_text()","attlistdecl()","attlistdecl()","attlistdecl?()","attribute()","attribute()","attribute_of()","attributes_of()","axe()","boolean()","buffer()","buffer_encoding=()","bytes()","cdata()","cdata()","cdata?()","cdatas()","ceiling()","characters()","check()","children()","children()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","collect()","comment()","comment()","comment?()","comments()","compare_language()","concat()","contains()","context()","context()","context=()","count()","create_from()","current_line()","current_line()","dclone()","deafen()","decode()","deep_clone()","default()","delete()","delete()","delete()","delete_all()","delete_all()","delete_at()","delete_attribute()","delete_element()","delete_if()","delete_namespace()","doctype()","doctype()","doctype()","doctype()","doctype()","doctype?()","doctype_end()","document()","document()","document()","done?()","dowrite()","dump()","each()","each()","each()","each()","each()","each()","each()","each()","each_attribute()","each_child()","each_element()","each_element_with_attribute()","each_element_with_text()","each_index()","each_recursive()","element=()","elementdecl()","elementdecl()","elementdecl?()","empty?()","empty?()","empty?()","empty?()","empty?()","encode()","encoding()","encoding=()","encoding=()","encoding=()","end_document()","end_element()","end_element?()","end_prefix_mapping()","ensure_buffer()","ensure_buffer()","entity()","entity()","entity()","entity?()","entity_expansion_limit()","entity_expansion_limit()","entity_expansion_limit=()","entity_expansion_limit=()","entity_expansion_text_limit()","entity_expansion_text_limit()","entity_expansion_text_limit=()","entity_expansion_text_limit=()","entitydecl()","entitydecl()","entitydecl?()","error?()","event_type()","expand()","expand_ref_in()","expanded_name()","expected()","expected()","expected()","expected()","expected()","expected()","false()","filter()","find_first_recursive()","first()","first()","first()","floor()","fully_expanded_name()","function()","generate_event()","get_attribute()","get_attribute_ns()","get_elements()","get_first()","get_namespace()","get_text()","has_attributes?()","has_elements?()","has_name?()","has_name?()","has_next?()","has_text?()","hash()","id()","ignore_whitespace_nodes()","include?()","indent()","indent_text()","index()","index()","index_in_parent()","inject()","insert_after()","insert_before()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","instruction()","instruction?()","instructions()","lang()","last()","length()","length()","line()","listen()","local_name()","local_name()","local_name=()","match()","match()","match()","match()","match()","matches?()","matches?()","matches?()","matches?()","matches?()","matches?()","matches?()","method_missing()","name()","name()","name()","name()","name()","name=()","name=()","namespace()","namespace()","namespace()","namespace=()","namespace_context()","namespace_context=()","namespace_uri()","namespaces()","namespaces()","namespaces=()","namespaces=()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next()","next()","next()","next()","next()","next()","next_current()","next_element()","next_sibling=()","next_sibling_node()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","normalize()","normalize_space()","normalized()","normalized=()","not()","notation()","notationdecl()","notationdecl()","notationdecl?()","notations()","nowrite()","number()","old_enc=()","parent()","parent()","parent=()","parent=()","parent=()","parent=()","parent?()","parent?()","parse()","parse()","parse()","parse()","parse()","parse()","parse()","parse()","parse_args()","parse_helper()","parse_source()","parse_source()","parse_stream()","peek()","peek()","position()","position()","position()","position()","position()","position=()","preciate_to_string()","predicate()","predicate()","predicate()","predicate_to_path()","prefix()","prefix()","prefixes()","prefixes()","previous=()","previous_element()","previous_sibling=()","previous_sibling_node()","processing_instruction()","processing_instruction()","progress()","public()","pull()","pull()","push()","raw()","read()","read()","read_until()","read_until()","receive()","record_entity_expansion()","remove()","remove()","replace_child()","replace_with()","reset()","reset()","reset()","reset()","reset()","rewind()","rewind()","root()","root()","root()","root_node()","round()","send()","single?()","singleton_method_added()","size()","size()","size()","size()","source()","stand_alone?()","start_document()","start_element()","start_element?()","start_prefix_mapping()","starts_with()","stream=()","string()","string_length()","string_value()","substring()","substring_after()","substring_before()","sum()","system()","tag_end()","tag_start()","text()","text()","text()","text=()","text=()","text?()","texts()","to_a()","to_a()","to_a()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_string()","translate()","true()","unnormalize()","unnormalized()","unshift()","unshift()","unshift()","validate()","value()","value()","value()","value()","value=()","variables()","variables=()","variables=()","version()","whitespace()","wrap()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write_cdata()","write_cdata()","write_comment()","write_comment()","write_document()","write_document()","write_element()","write_element()","write_element()","write_instruction()","write_text()","write_text()","write_text()","write_with_substitution()","xml_decl()","xmldecl()","xmldecl()","xmldecl()","xmldecl?()","xpath()","xpath()","xpath()","license","news","readme","context","child","document","element","node","parent","child_toc","document_toc","element_toc","master_toc","node_toc","parent_toc","tutorial"],"longSearchIndex":["rexml","rexml::attlistdecl","rexml::attribute","rexml::attributes","rexml::cdata","rexml::child","rexml::comment","rexml::dclonable","rexml::dtd","rexml::dtd::attlistdecl","rexml::dtd::elementdecl","rexml::dtd::entitydecl","rexml::dtd::notationdecl","rexml::dtd::parser","rexml::declaration","rexml::doctype","rexml::document","rexml::element","rexml::elementdecl","rexml::elements","rexml::encoding","rexml::entity","rexml::entityconst","rexml::externalentity","rexml::formatters","rexml::formatters::default","rexml::formatters::pretty","rexml::formatters::transitive","rexml::functions","rexml::iosource","rexml::instruction","rexml::light","rexml::light::node","rexml::namespace","rexml::node","rexml::notationdecl","rexml::output","rexml::parent","rexml::parseexception","rexml::parsers","rexml::parsers::baseparser","rexml::parsers::baseparser::private","rexml::parsers::lightparser","rexml::parsers::pullevent","rexml::parsers::pullparser","rexml::parsers::sax2parser","rexml::parsers::streamparser","rexml::parsers::treeparser","rexml::parsers::ultralightparser","rexml::parsers::xpathparser","rexml::quickpath","rexml::referencewriter","rexml::sax2listener","rexml::security","rexml::source","rexml::sourcefactory","rexml::streamlistener","rexml::text","rexml::undefinednamespaceexception","rexml::validation","rexml::validation::choice","rexml::validation::event","rexml::validation::interleave","rexml::validation::oneormore","rexml::validation::optional","rexml::validation::ref","rexml::validation::relaxng","rexml::validation::sequence","rexml::validation::state","rexml::validation::validationexception","rexml::validation::validator","rexml::validation::zeroormore","rexml::xmldecl","rexml::xmltokens","rexml::xpath","rexml::xpathnode","rexml::xpathparser","rexml::attributes#<<()","rexml::document#<<()","rexml::elements#<<()","rexml::light::node#<<()","rexml::output#<<()","rexml::parent#<<()","rexml::text#<<()","rexml::validation::choice#<<()","rexml::validation::state#<<()","rexml::comment#<=>()","rexml::text#<=>()","rexml::attribute#==()","rexml::comment#==()","rexml::instruction#==()","rexml::validation::event#==()","rexml::xmldecl#==()","rexml::light::node#=~()","rexml::attlistdecl#[]()","rexml::attributes#[]()","rexml::element#[]()","rexml::elements#[]()","rexml::light::node#[]()","rexml::parent#[]()","rexml::parsers::pullevent#[]()","rexml::attributes#[]=()","rexml::elements#[]=()","rexml::light::node#[]=()","rexml::parent#[]=()","rexml::xpathparser#[]=()","rexml::parsers::xpathparser#abbreviate()","rexml::attributes#add()","rexml::doctype#add()","rexml::document#add()","rexml::elements#add()","rexml::parent#add()","rexml::element#add_attribute()","rexml::element#add_attributes()","rexml::document#add_element()","rexml::element#add_element()","rexml::validation::choice#add_event_to_arry()","rexml::validation::state#add_event_to_arry()","rexml::parsers::baseparser#add_listener()","rexml::parsers::lightparser#add_listener()","rexml::parsers::pullparser#add_listener()","rexml::parsers::sax2parser#add_listener()","rexml::parsers::streamparser#add_listener()","rexml::parsers::treeparser#add_listener()","rexml::parsers::ultralightparser#add_listener()","rexml::element#add_namespace()","rexml::element#add_text()","rexml::sax2listener#attlistdecl()","rexml::streamlistener#attlistdecl()","rexml::parsers::pullevent#attlistdecl?()","rexml::element#attribute()","rexml::quickpath::attribute()","rexml::doctype#attribute_of()","rexml::doctype#attributes_of()","rexml::quickpath::axe()","rexml::functions::boolean()","rexml::source#buffer()","rexml::source#buffer_encoding=()","rexml::child#bytes()","rexml::sax2listener#cdata()","rexml::streamlistener#cdata()","rexml::parsers::pullevent#cdata?()","rexml::element#cdatas()","rexml::functions::ceiling()","rexml::sax2listener#characters()","rexml::text::check()","rexml::light::node#children()","rexml::parent#children()","rexml::attribute#clone()","rexml::cdata#clone()","rexml::comment#clone()","rexml::doctype#clone()","rexml::document#clone()","rexml::element#clone()","rexml::instruction#clone()","rexml::text#clone()","rexml::xmldecl#clone()","rexml::elements#collect()","rexml::sax2listener#comment()","rexml::streamlistener#comment()","rexml::parsers::pullevent#comment?()","rexml::element#comments()","rexml::functions::compare_language()","rexml::functions::concat()","rexml::functions::contains()","rexml::doctype#context()","rexml::parseexception#context()","rexml::functions::context=()","rexml::functions::count()","rexml::sourcefactory::create_from()","rexml::iosource#current_line()","rexml::source#current_line()","rexml::dclonable#dclone()","rexml::parsers::sax2parser#deafen()","rexml::encoding#decode()","rexml::parent#deep_clone()","rexml::xmldecl::default()","rexml::attributes#delete()","rexml::elements#delete()","rexml::parent#delete()","rexml::attributes#delete_all()","rexml::elements#delete_all()","rexml::parent#delete_at()","rexml::element#delete_attribute()","rexml::element#delete_element()","rexml::parent#delete_if()","rexml::element#delete_namespace()","rexml::attribute#doctype()","rexml::document#doctype()","rexml::sax2listener#doctype()","rexml::streamlistener#doctype()","rexml::text#doctype()","rexml::parsers::pullevent#doctype?()","rexml::streamlistener#doctype_end()","rexml::child#document()","rexml::document#document()","rexml::element#document()","rexml::validation::event#done?()","rexml::xmldecl#dowrite()","rexml::validation::validator#dump()","rexml::attlistdecl#each()","rexml::attributes#each()","rexml::elements#each()","rexml::light::node#each()","rexml::parent#each()","rexml::parsers::pullparser#each()","rexml::quickpath::each()","rexml::xpath::each()","rexml::attributes#each_attribute()","rexml::parent#each_child()","rexml::element#each_element()","rexml::element#each_element_with_attribute()","rexml::element#each_element_with_text()","rexml::parent#each_index()","rexml::node#each_recursive()","rexml::attribute#element=()","rexml::sax2listener#elementdecl()","rexml::streamlistener#elementdecl()","rexml::parsers::pullevent#elementdecl?()","rexml::elements#empty?()","rexml::iosource#empty?()","rexml::parsers::baseparser#empty?()","rexml::source#empty?()","rexml::text#empty?()","rexml::encoding#encode()","rexml::document#encoding()","rexml::encoding#encoding=()","rexml::source#encoding=()","rexml::xmldecl#encoding=()","rexml::sax2listener#end_document()","rexml::sax2listener#end_element()","rexml::parsers::pullevent#end_element?()","rexml::sax2listener#end_prefix_mapping()","rexml::iosource#ensure_buffer()","rexml::source#ensure_buffer()","rexml::doctype#entity()","rexml::parsers::baseparser#entity()","rexml::streamlistener#entity()","rexml::parsers::pullevent#entity?()","rexml::document::entity_expansion_limit()","rexml::security::entity_expansion_limit()","rexml::document::entity_expansion_limit=()","rexml::security::entity_expansion_limit=()","rexml::document::entity_expansion_text_limit()","rexml::security::entity_expansion_text_limit()","rexml::document::entity_expansion_text_limit=()","rexml::security::entity_expansion_text_limit=()","rexml::sax2listener#entitydecl()","rexml::streamlistener#entitydecl()","rexml::parsers::pullevent#entitydecl?()","rexml::parsers::pullevent#error?()","rexml::parsers::pullevent#event_type()","rexml::parsers::xpathparser#expand()","rexml::validation::state#expand_ref_in()","rexml::document#expanded_name()","rexml::validation::choice#expected()","rexml::validation::interleave#expected()","rexml::validation::oneormore#expected()","rexml::validation::optional#expected()","rexml::validation::state#expected()","rexml::validation::zeroormore#expected()","rexml::functions::false()","rexml::quickpath::filter()","rexml::node#find_first_recursive()","rexml::quickpath::first()","rexml::xpath::first()","rexml::xpathparser#first()","rexml::functions::floor()","rexml::namespace#fully_expanded_name()","rexml::quickpath::function()","rexml::validation::state#generate_event()","rexml::attributes#get_attribute()","rexml::attributes#get_attribute_ns()","rexml::element#get_elements()","rexml::xpathparser#get_first()","rexml::functions::get_namespace()","rexml::element#get_text()","rexml::element#has_attributes?()","rexml::element#has_elements?()","rexml::light::node#has_name?()","rexml::namespace#has_name?()","rexml::parsers::baseparser#has_next?()","rexml::element#has_text?()","rexml::attribute#hash()","rexml::functions::id()","rexml::element#ignore_whitespace_nodes()","rexml::attlistdecl#include?()","rexml::node#indent()","rexml::text#indent_text()","rexml::elements#index()","rexml::parent#index()","rexml::node#index_in_parent()","rexml::elements#inject()","rexml::parent#insert_after()","rexml::parent#insert_before()","rexml::attribute#inspect()","rexml::element#inspect()","rexml::instruction#inspect()","rexml::parsers::pullevent#inspect()","rexml::text#inspect()","rexml::validation::choice#inspect()","rexml::validation::event#inspect()","rexml::validation::interleave#inspect()","rexml::validation::ref#inspect()","rexml::validation::state#inspect()","rexml::xmldecl#inspect()","rexml::streamlistener#instruction()","rexml::parsers::pullevent#instruction?()","rexml::element#instructions()","rexml::functions::lang()","rexml::functions::last()","rexml::attributes#length()","rexml::parent#length()","rexml::parseexception#line()","rexml::parsers::sax2parser#listen()","rexml::functions::local_name()","rexml::light::node#local_name()","rexml::light::node#local_name=()","rexml::iosource#match()","rexml::quickpath::match()","rexml::source#match()","rexml::xpath::match()","rexml::xpathparser#match()","rexml::entity::matches?()","rexml::validation::choice#matches?()","rexml::validation::event#matches?()","rexml::validation::interleave#matches?()","rexml::validation::oneormore#matches?()","rexml::validation::optional#matches?()","rexml::validation::sequence#matches?()","rexml::quickpath::method_missing()","rexml::document#name()","rexml::functions::name()","rexml::light::node#name()","rexml::notationdecl#name()","rexml::quickpath::name()","rexml::light::node#name=()","rexml::namespace#name=()","rexml::attribute#namespace()","rexml::element#namespace()","rexml::light::node#namespace()","rexml::light::node#namespace=()","rexml::functions::namespace_context()","rexml::functions::namespace_context=()","rexml::functions::namespace_uri()","rexml::attributes#namespaces()","rexml::element#namespaces()","rexml::parsers::xpathparser#namespaces=()","rexml::xpathparser#namespaces=()","rexml::attlistdecl::new()","rexml::attribute::new()","rexml::attributes::new()","rexml::cdata::new()","rexml::child::new()","rexml::comment::new()","rexml::dtd::elementdecl::new()","rexml::dtd::entitydecl::new()","rexml::dtd::notationdecl::new()","rexml::declaration::new()","rexml::doctype::new()","rexml::document::new()","rexml::element::new()","rexml::elementdecl::new()","rexml::elements::new()","rexml::entity::new()","rexml::externalentity::new()","rexml::formatters::default::new()","rexml::formatters::pretty::new()","rexml::formatters::transitive::new()","rexml::iosource::new()","rexml::instruction::new()","rexml::light::node::new()","rexml::notationdecl::new()","rexml::output::new()","rexml::parent::new()","rexml::parseexception::new()","rexml::parsers::baseparser::new()","rexml::parsers::lightparser::new()","rexml::parsers::pullevent::new()","rexml::parsers::pullparser::new()","rexml::parsers::sax2parser::new()","rexml::parsers::streamparser::new()","rexml::parsers::treeparser::new()","rexml::parsers::ultralightparser::new()","rexml::referencewriter::new()","rexml::source::new()","rexml::text::new()","rexml::undefinednamespaceexception::new()","rexml::validation::choice::new()","rexml::validation::event::new()","rexml::validation::interleave::new()","rexml::validation::oneormore::new()","rexml::validation::ref::new()","rexml::validation::relaxng::new()","rexml::validation::state::new()","rexml::validation::validationexception::new()","rexml::xmldecl::new()","rexml::xpathnode::new()","rexml::xpathparser::new()","rexml::validation::choice#next()","rexml::validation::interleave#next()","rexml::validation::oneormore#next()","rexml::validation::optional#next()","rexml::validation::state#next()","rexml::validation::zeroormore#next()","rexml::validation::interleave#next_current()","rexml::element#next_element()","rexml::child#next_sibling=()","rexml::node#next_sibling_node()","rexml::attlistdecl#node_type()","rexml::attribute#node_type()","rexml::comment#node_type()","rexml::doctype#node_type()","rexml::document#node_type()","rexml::element#node_type()","rexml::instruction#node_type()","rexml::light::node#node_type()","rexml::text#node_type()","rexml::xmldecl#node_type()","rexml::parsers::baseparser#normalize()","rexml::functions::normalize_space()","rexml::entity#normalized()","rexml::attribute#normalized=()","rexml::functions::not()","rexml::doctype#notation()","rexml::sax2listener#notationdecl()","rexml::streamlistener#notationdecl()","rexml::parsers::pullevent#notationdecl?()","rexml::doctype#notations()","rexml::xmldecl#nowrite()","rexml::functions::number()","rexml::xmldecl#old_enc=()","rexml::elements#parent()","rexml::light::node#parent()","rexml::child#parent=()","rexml::entity#parent=()","rexml::light::node#parent=()","rexml::text#parent=()","rexml::node#parent?()","rexml::parent#parent?()","rexml::dtd::parser::parse()","rexml::parsers::lightparser#parse()","rexml::parsers::sax2parser#parse()","rexml::parsers::streamparser#parse()","rexml::parsers::treeparser#parse()","rexml::parsers::ultralightparser#parse()","rexml::parsers::xpathparser#parse()","rexml::xpathparser#parse()","rexml::quickpath::parse_args()","rexml::dtd::parser::parse_helper()","rexml::dtd::entitydecl::parse_source()","rexml::dtd::notationdecl::parse_source()","rexml::document::parse_stream()","rexml::parsers::baseparser#peek()","rexml::parsers::pullparser#peek()","rexml::functions::position()","rexml::parseexception#position()","rexml::parsers::baseparser#position()","rexml::source#position()","rexml::xpathnode#position()","rexml::source#position=()","rexml::parsers::xpathparser#preciate_to_string()","rexml::parsers::xpathparser#predicate()","rexml::quickpath::predicate()","rexml::xpathparser#predicate()","rexml::parsers::xpathparser#predicate_to_path()","rexml::attribute#prefix()","rexml::light::node#prefix()","rexml::attributes#prefixes()","rexml::element#prefixes()","rexml::validation::state#previous=()","rexml::element#previous_element()","rexml::child#previous_sibling=()","rexml::node#previous_sibling_node()","rexml::functions::processing_instruction()","rexml::sax2listener#processing_instruction()","rexml::sax2listener#progress()","rexml::doctype#public()","rexml::parsers::baseparser#pull()","rexml::parsers::pullparser#pull()","rexml::parent#push()","rexml::element#raw()","rexml::iosource#read()","rexml::source#read()","rexml::iosource#read_until()","rexml::source#read_until()","rexml::validation::relaxng#receive()","rexml::document#record_entity_expansion()","rexml::attribute#remove()","rexml::child#remove()","rexml::parent#replace_child()","rexml::child#replace_with()","rexml::validation::choice#reset()","rexml::validation::interleave#reset()","rexml::validation::oneormore#reset()","rexml::validation::state#reset()","rexml::validation::validator#reset()","rexml::parsers::lightparser#rewind()","rexml::parsers::ultralightparser#rewind()","rexml::document#root()","rexml::element#root()","rexml::light::node#root()","rexml::element#root_node()","rexml::functions::round()","rexml::functions::send()","rexml::validation::event#single?()","rexml::functions::singleton_method_added()","rexml::attributes#size()","rexml::elements#size()","rexml::light::node#size()","rexml::parent#size()","rexml::parsers::sax2parser#source()","rexml::document#stand_alone?()","rexml::sax2listener#start_document()","rexml::sax2listener#start_element()","rexml::parsers::pullevent#start_element?()","rexml::sax2listener#start_prefix_mapping()","rexml::functions::starts_with()","rexml::parsers::baseparser#stream=()","rexml::functions::string()","rexml::functions::string_length()","rexml::functions::string_value()","rexml::functions::substring()","rexml::functions::substring_after()","rexml::functions::substring_before()","rexml::functions::sum()","rexml::doctype#system()","rexml::streamlistener#tag_end()","rexml::streamlistener#tag_start()","rexml::element#text()","rexml::functions::text()","rexml::streamlistener#text()","rexml::element#text=()","rexml::light::node#text=()","rexml::parsers::pullevent#text?()","rexml::element#texts()","rexml::attributes#to_a()","rexml::elements#to_a()","rexml::parent#to_a()","rexml::attribute#to_s()","rexml::cdata#to_s()","rexml::dtd::entitydecl#to_s()","rexml::dtd::notationdecl#to_s()","rexml::declaration#to_s()","rexml::entity#to_s()","rexml::externalentity#to_s()","rexml::light::node#to_s()","rexml::node#to_s()","rexml::notationdecl#to_s()","rexml::output#to_s()","rexml::parseexception#to_s()","rexml::text#to_s()","rexml::validation::event#to_s()","rexml::validation::ref#to_s()","rexml::validation::state#to_s()","rexml::attribute#to_string()","rexml::functions::translate()","rexml::functions::true()","rexml::parsers::baseparser#unnormalize()","rexml::entity#unnormalized()","rexml::parent#unshift()","rexml::parsers::baseparser#unshift()","rexml::parsers::pullparser#unshift()","rexml::validation::validator#validate()","rexml::attribute#value()","rexml::cdata#value()","rexml::entity#value()","rexml::text#value()","rexml::text#value=()","rexml::functions::variables()","rexml::functions::variables=()","rexml::xpathparser#variables=()","rexml::document#version()","rexml::element#whitespace()","rexml::text#wrap()","rexml::attlistdecl#write()","rexml::attribute#write()","rexml::cdata#write()","rexml::comment#write()","rexml::dtd::entitydecl#write()","rexml::dtd::notationdecl#write()","rexml::declaration#write()","rexml::doctype#write()","rexml::document#write()","rexml::element#write()","rexml::entity#write()","rexml::externalentity#write()","rexml::formatters::default#write()","rexml::instruction#write()","rexml::notationdecl#write()","rexml::referencewriter#write()","rexml::text#write()","rexml::xmldecl#write()","rexml::formatters::default#write_cdata()","rexml::formatters::pretty#write_cdata()","rexml::formatters::default#write_comment()","rexml::formatters::pretty#write_comment()","rexml::formatters::default#write_document()","rexml::formatters::pretty#write_document()","rexml::formatters::default#write_element()","rexml::formatters::pretty#write_element()","rexml::formatters::transitive#write_element()","rexml::formatters::default#write_instruction()","rexml::formatters::default#write_text()","rexml::formatters::pretty#write_text()","rexml::formatters::transitive#write_text()","rexml::text#write_with_substitution()","rexml::document#xml_decl()","rexml::sax2listener#xmldecl()","rexml::streamlistener#xmldecl()","rexml::xmldecl#xmldecl()","rexml::parsers::pullevent#xmldecl?()","rexml::attribute#xpath()","rexml::element#xpath()","rexml::text#xpath()","","","","","","","","","","","","","","","",""],"info":[["REXML","","REXML.html","","<p>Module REXML provides classes and methods for parsing, editing, and generating XML.\n<p>Implementation\n<p>REXML: …\n"],["REXML::AttlistDecl","","REXML/AttlistDecl.html","","<p>This class needs:\n<p>Documentation\n<p>Work!  Not all types of attlists are intelligently parsed, so we just\n"],["REXML::Attribute","","REXML/Attribute.html","","<p>Defines an Element Attribute; IE, a attribute=value pair, as in: &lt;element attribute=“value”/&gt;. …\n"],["REXML::Attributes","","REXML/Attributes.html","","<p>A class that defines the set of Attributes of an Element and provides operations for accessing elements …\n"],["REXML::CData","","REXML/CData.html","",""],["REXML::Child","","REXML/Child.html","","<p>A Child object is something contained by a parent, and this class contains methods to support that.  …\n"],["REXML::Comment","","REXML/Comment.html","","<p>Represents an XML comment; that is, text between &lt;!– … –&gt;\n"],["REXML::DClonable","","REXML/DClonable.html","",""],["REXML::DTD","","REXML/DTD.html","",""],["REXML::DTD::AttlistDecl","","REXML/DTD/AttlistDecl.html","",""],["REXML::DTD::ElementDecl","","REXML/DTD/ElementDecl.html","",""],["REXML::DTD::EntityDecl","","REXML/DTD/EntityDecl.html","",""],["REXML::DTD::NotationDecl","","REXML/DTD/NotationDecl.html","",""],["REXML::DTD::Parser","","REXML/DTD/Parser.html","",""],["REXML::Declaration","","REXML/Declaration.html","","<p>This is an abstract class.  You never use this directly; it serves as a parent class for the specific …\n"],["REXML::DocType","","REXML/DocType.html","","<p>Represents an XML DOCTYPE declaration; that is, the contents of &lt;!DOCTYPE … &gt;.  DOCTYPES can …\n"],["REXML::Document","","REXML/Document.html","","<p>Represents an XML document.\n<p>A document may have:\n<p>A single child that may be accessed via method #root. …\n"],["REXML::Element","","REXML/Element.html","","<p>An REXML::Element object represents an XML element.\n<p>An element:\n<p>Has a name (string).\n"],["REXML::ElementDecl","","REXML/ElementDecl.html","",""],["REXML::Elements","","REXML/Elements.html","","<p>A class which provides filtering of children for Elements, and XPath search support.  You are expected …\n"],["REXML::Encoding","","REXML/Encoding.html","",""],["REXML::Entity","","REXML/Entity.html","",""],["REXML::EntityConst","","REXML/EntityConst.html","","<p>This is a set of entity constants – the ones defined in the XML specification.  These are <code>gt</code>, <code>lt</code>, <code>amp</code> …\n"],["REXML::ExternalEntity","","REXML/ExternalEntity.html","",""],["REXML::Formatters","","REXML/Formatters.html","",""],["REXML::Formatters::Default","","REXML/Formatters/Default.html","",""],["REXML::Formatters::Pretty","","REXML/Formatters/Pretty.html","","<p>Pretty-prints an XML document.  This destroys whitespace in text nodes and will insert carriage returns …\n"],["REXML::Formatters::Transitive","","REXML/Formatters/Transitive.html","","<p>The Transitive formatter writes an XML document that parses to an identical document as the source document. …\n"],["REXML::Functions","","REXML/Functions.html","","<p>If you add a method, keep in mind two things: (1) the first argument will always be a list of nodes from …\n"],["REXML::IOSource","","REXML/IOSource.html","","<p>A Source that wraps an IO.  See the Source class for method documentation\n"],["REXML::Instruction","","REXML/Instruction.html","","<p>Represents an XML Instruction; IE, &lt;? … ?&gt; TODO: Add parent arg (3rd arg) to constructor\n"],["REXML::Light","","REXML/Light.html","",""],["REXML::Light::Node","","REXML/Light/Node.html","","<p>Represents a tagged XML element.  Elements are characterized by having children, attributes, and names, …\n"],["REXML::Namespace","","REXML/Namespace.html","","<p>Adds named attributes to an object.\n"],["REXML::Node","","REXML/Node.html","","<p>Represents a node in the tree.  Nodes are never encountered except as superclasses of other objects. …\n"],["REXML::NotationDecl","","REXML/NotationDecl.html","",""],["REXML::Output","","REXML/Output.html","",""],["REXML::Parent","","REXML/Parent.html","","<p>A parent has children, and has methods for accessing them.  The Parent class is never encountered except …\n"],["REXML::ParseException","","REXML/ParseException.html","",""],["REXML::Parsers","","REXML/Parsers.html","",""],["REXML::Parsers::BaseParser","","REXML/Parsers/BaseParser.html","","<p>Using the Pull Parser\n<p><em>This API is experimental, and subject to change.</em>\n\n<pre>parser = PullParser.new( &quot;&lt;a&gt;text&lt;b ...</pre>\n"],["REXML::Parsers::BaseParser::Private","","REXML/Parsers/BaseParser/Private.html","",""],["REXML::Parsers::LightParser","","REXML/Parsers/LightParser.html","",""],["REXML::Parsers::PullEvent","","REXML/Parsers/PullEvent.html","","<p>A parsing event.  The contents of the event are accessed as an +Array?, and the type is given either …\n"],["REXML::Parsers::PullParser","","REXML/Parsers/PullParser.html","","<p>Using the Pull Parser\n<p><em>This API is experimental, and subject to change.</em>\n\n<pre>parser = PullParser.new( &quot;&lt;a&gt;text&lt;b ...</pre>\n"],["REXML::Parsers::SAX2Parser","","REXML/Parsers/SAX2Parser.html","","<p>SAX2Parser\n"],["REXML::Parsers::StreamParser","","REXML/Parsers/StreamParser.html","",""],["REXML::Parsers::TreeParser","","REXML/Parsers/TreeParser.html","",""],["REXML::Parsers::UltraLightParser","","REXML/Parsers/UltraLightParser.html","",""],["REXML::Parsers::XPathParser","","REXML/Parsers/XPathParser.html","","<p>You don&#39;t want to use this class.  Really.  Use XPath, which is a wrapper for this class.  Believe …\n"],["REXML::QuickPath","","REXML/QuickPath.html","",""],["REXML::ReferenceWriter","","REXML/ReferenceWriter.html","",""],["REXML::SAX2Listener","","REXML/SAX2Listener.html","","<p>A template for stream parser listeners. Note that the declarations (attlistdecl, elementdecl, etc) are …\n"],["REXML::Security","","REXML/Security.html","",""],["REXML::Source","","REXML/Source.html","","<p>A Source can be searched for patterns, and wraps buffers and other objects and provides consumption of …\n"],["REXML::SourceFactory","","REXML/SourceFactory.html","","<p>Generates Source-s.  USE THIS CLASS.\n"],["REXML::StreamListener","","REXML/StreamListener.html","","<p>A template for stream parser listeners. Note that the declarations (attlistdecl, elementdecl, etc) are …\n"],["REXML::Text","","REXML/Text.html","","<p>Represents text nodes in an XML document\n"],["REXML::UndefinedNamespaceException","","REXML/UndefinedNamespaceException.html","",""],["REXML::Validation","","REXML/Validation.html","",""],["REXML::Validation::Choice","","REXML/Validation/Choice.html","",""],["REXML::Validation::Event","","REXML/Validation/Event.html","",""],["REXML::Validation::Interleave","","REXML/Validation/Interleave.html","",""],["REXML::Validation::OneOrMore","","REXML/Validation/OneOrMore.html","",""],["REXML::Validation::Optional","","REXML/Validation/Optional.html","",""],["REXML::Validation::Ref","","REXML/Validation/Ref.html","",""],["REXML::Validation::RelaxNG","","REXML/Validation/RelaxNG.html","","<p>Implemented:\n<p>empty\n<p>element\n"],["REXML::Validation::Sequence","","REXML/Validation/Sequence.html","",""],["REXML::Validation::State","","REXML/Validation/State.html","",""],["REXML::Validation::ValidationException","","REXML/Validation/ValidationException.html","",""],["REXML::Validation::Validator","","REXML/Validation/Validator.html","",""],["REXML::Validation::ZeroOrMore","","REXML/Validation/ZeroOrMore.html","",""],["REXML::XMLDecl","","REXML/XMLDecl.html","","<p>NEEDS DOCUMENTATION\n"],["REXML::XMLTokens","","REXML/XMLTokens.html","","<p>Defines a number of tokens used for parsing XML.  Not for general consumption.\n"],["REXML::XPath","","REXML/XPath.html","","<p>Wrapper class.  Use this class to access the XPath functions.\n"],["REXML::XPathNode","","REXML/XPathNode.html","","<p>@private\n"],["REXML::XPathParser","","REXML/XPathParser.html","","<p>You don&#39;t want to use this class.  Really.  Use XPath, which is a wrapper for this class.  Believe …\n"],["<<","REXML::Attributes","REXML/Attributes.html#method-i-3C-3C","( attribute )",""],["<<","REXML::Document","REXML/Document.html#method-i-3C-3C","( child )",""],["<<","REXML::Elements","REXML/Elements.html#method-i-3C-3C","(element=nil)",""],["<<","REXML::Light::Node","REXML/Light/Node.html#method-i-3C-3C","(element)","<p>Append a child to this element, optionally under a provided namespace. The namespace argument is ignored …\n"],["<<","REXML::Output","REXML/Output.html#method-i-3C-3C","( content )",""],["<<","REXML::Parent","REXML/Parent.html#method-i-3C-3C","( object )",""],["<<","REXML::Text","REXML/Text.html#method-i-3C-3C","( to_append )","<p>Appends text to this text node.  The text is appended in the <code>raw</code> mode of this text node.\n<p><code>returns</code> the text …\n"],["<<","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-3C-3C","( event )",""],["<<","REXML::Validation::State","REXML/Validation/State.html#method-i-3C-3C","( event )",""],["<=>","REXML::Comment","REXML/Comment.html#method-i-3C-3D-3E","(other)","<p>Compares this Comment to another; the contents of the comment are used in the comparison.\n"],["<=>","REXML::Text","REXML/Text.html#method-i-3C-3D-3E","( other )","<p><code>other</code> a String or a Text <code>returns</code> the result of (to_s &lt;=&gt; arg.to_s)\n"],["==","REXML::Attribute","REXML/Attribute.html#method-i-3D-3D","( other )","<p>Returns true if other is an Attribute and has the same name and value, false otherwise.\n"],["==","REXML::Comment","REXML/Comment.html#method-i-3D-3D","( other )","<p>Compares this Comment to another; the contents of the comment are used in the comparison.\n"],["==","REXML::Instruction","REXML/Instruction.html#method-i-3D-3D","( other )","<p>@return true if other is an Instruction, and the content and target of the other matches the target and …\n"],["==","REXML::Validation::Event","REXML/Validation/Event.html#method-i-3D-3D","( other )",""],["==","REXML::XMLDecl","REXML/XMLDecl.html#method-i-3D-3D","( other )",""],["=~","REXML::Light::Node","REXML/Light/Node.html#method-i-3D~","( path )",""],["[]","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-5B-5D","(key)","<p>Access the attlist attribute/value pairs.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">value</span> = <span class=\"ruby-identifier\">attlist_decl</span>[ <span class=\"ruby-identifier\">attribute_name</span> ]\n</pre>\n"],["[]","REXML::Attributes","REXML/Attributes.html#method-i-5B-5D","(name)","<p>Returns the value for the attribute given by <code>name</code>, if it exists; otherwise <code>nil</code>. The value returned is …\n"],["[]","REXML::Element","REXML/Element.html#method-i-5B-5D","(name_or_index)","<p>With integer argument <code>index</code> given, returns the child at offset <code>index</code>, or <code>nil</code> if none:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["[]","REXML::Elements","REXML/Elements.html#method-i-5B-5D","( index, name=nil)","<p>Returns the first Element object selected by the arguments, if any found, or <code>nil</code> if none found.\n<p>Notes: …\n"],["[]","REXML::Light::Node","REXML/Light/Node.html#method-i-5B-5D","( reference, ns=nil )",""],["[]","REXML::Parent","REXML/Parent.html#method-i-5B-5D","( index )","<p>Fetches a child at a given index @param index the Integer index of the child to fetch\n"],["[]","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-5B-5D","( start, endd=nil)",""],["[]=","REXML::Attributes","REXML/Attributes.html#method-i-5B-5D-3D","( name, value )","<p>When <code>value</code> is non-<code>nil</code>, assigns that to the attribute for the given <code>name</code>, overwriting the previous value …\n"],["[]=","REXML::Elements","REXML/Elements.html#method-i-5B-5D-3D","( index, element )","<p>Replaces or adds an element.\n<p>When <code>eles[index]</code> exists, replaces it with <code>replacement_element</code> and returns …\n"],["[]=","REXML::Light::Node","REXML/Light/Node.html#method-i-5B-5D-3D","( reference, ns, value=nil )","<p>Doesn&#39;t handle namespaces yet\n"],["[]=","REXML::Parent","REXML/Parent.html#method-i-5B-5D-3D","( *args )","<p>Set an index entry.  See Array.[]= @param index the index of the element to set @param opt either the …\n"],["[]=","REXML::XPathParser","REXML/XPathParser.html#method-i-5B-5D-3D","( variable_name, value )",""],["abbreviate","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-abbreviate","(path_or_parsed)",""],["add","REXML::Attributes","REXML/Attributes.html#method-i-add","( attribute )","<p>Adds attribute <code>attribute</code>, replacing the previous attribute of the same name if it exists; returns <code>attribute</code> …\n"],["add","REXML::DocType","REXML/DocType.html#method-i-add","(child)",""],["add","REXML::Document","REXML/Document.html#method-i-add","( child )","<p>Adds an object to the document; returns <code>self</code>.\n<p>When argument <code>xml_decl</code> is given, it must be an REXML::XMLDecl …\n"],["add","REXML::Elements","REXML/Elements.html#method-i-add","(element=nil)","<p>Adds an element; returns the element added.\n<p>With no argument, creates and adds a new element. The new …\n"],["add","REXML::Parent","REXML/Parent.html#method-i-add","( object )",""],["add_attribute","REXML::Element","REXML/Element.html#method-i-add_attribute","( key, value=nil )","<p>Adds an attribute to this element, overwriting any existing attribute by the same name.\n<p>With string argument …\n"],["add_attributes","REXML::Element","REXML/Element.html#method-i-add_attributes","(hash)","<p>Adds zero or more attributes to the element; returns the argument.\n<p>If hash argument <code>hash</code> is given, each …\n"],["add_element","REXML::Document","REXML/Document.html#method-i-add_element","(arg=nil, arg2=nil)","<p>Adds an element to the document by calling REXML::Element.add_element:\n\n<pre>REXML::Element.add_element(name_or_element, ...</pre>\n"],["add_element","REXML::Element","REXML/Element.html#method-i-add_element","(element, attrs=nil)","<p>Adds a child element, optionally setting attributes on the added element; returns the added element. …\n"],["add_event_to_arry","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-add_event_to_arry","( arry, evt )",""],["add_event_to_arry","REXML::Validation::State","REXML/Validation/State.html#method-i-add_event_to_arry","( arry, evt )",""],["add_listener","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-add_listener","( listener )",""],["add_namespace","REXML::Element","REXML/Element.html#method-i-add_namespace","( prefix, uri=nil )","<p>Adds a namespace to the element; returns <code>self</code>.\n<p>With the single argument <code>prefix</code>, adds a namespace using …\n"],["add_text","REXML::Element","REXML/Element.html#method-i-add_text","( text )","<p>Adds text to the element.\n<p>When string argument <code>string</code> is given, returns <code>nil</code>.\n<p>If the element has no child …\n"],["attlistdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-attlistdecl","(element, pairs, contents)","<p>If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is …\n"],["attlistdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-attlistdecl","(element_name, attributes, raw_content)","<p>If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is …\n"],["attlistdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-attlistdecl-3F","()","<p>Content: [ String text ]\n"],["attribute","REXML::Element","REXML/Element.html#method-i-attribute","( name, namespace=nil )","<p>Returns the string value for the given attribute name.\n<p>With only argument <code>name</code> given, returns the value …\n"],["attribute","REXML::QuickPath","REXML/QuickPath.html#method-c-attribute","( name )",""],["attribute_of","REXML::DocType","REXML/DocType.html#method-i-attribute_of","(element, attribute)",""],["attributes_of","REXML::DocType","REXML/DocType.html#method-i-attributes_of","(element)",""],["axe","REXML::QuickPath","REXML/QuickPath.html#method-c-axe","( elements, axe_name, rest )",""],["boolean","REXML::Functions","REXML/Functions.html#method-c-boolean","(object=@@context[:node])",""],["buffer","REXML::Source","REXML/Source.html#method-i-buffer","()","<p>The current buffer (what we&#39;re going to read next)\n"],["buffer_encoding=","REXML::Source","REXML/Source.html#method-i-buffer_encoding-3D","(encoding)",""],["bytes","REXML::Child","REXML/Child.html#method-i-bytes","()","<p>This doesn&#39;t yet handle encodings\n"],["cdata","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-cdata","(content)","<p>Called when &lt;![CDATA[ … ]]&gt; is encountered in a document. @p content “…”\n"],["cdata","REXML::StreamListener","REXML/StreamListener.html#method-i-cdata","(content)","<p>Called when &lt;![CDATA[ … ]]&gt; is encountered in a document. @p content “…”\n"],["cdata?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-cdata-3F","()","<p>Content: [ String text ]\n"],["cdatas","REXML::Element","REXML/Element.html#method-i-cdatas","()","<p>Returns a frozen array of the REXML::CData children of the element:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root&gt;\n    &lt;![CDATA[foo]]&gt; ...</pre>\n"],["ceiling","REXML::Functions","REXML/Functions.html#method-c-ceiling","( number )",""],["characters","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-characters","(text)",""],["check","REXML::Text","REXML/Text.html#method-c-check","(string, pattern, doctype)","<p>check for illegal characters\n"],["children","REXML::Light::Node","REXML/Light/Node.html#method-i-children","()",""],["children","REXML::Parent","REXML/Parent.html#method-i-children","()",""],["clone","REXML::Attribute","REXML/Attribute.html#method-i-clone","()","<p>Returns a copy of this attribute\n"],["clone","REXML::CData","REXML/CData.html#method-i-clone","()","<p>Make a copy of this object\n<p><em>Examples</em>\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">c</span> = <span class=\"ruby-constant\">CData</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;Some text&quot;</span> )\n<span class=\"ruby-identifier\">d</span> = <span class=\"ruby-identifier\">c</span>.<span class=\"ruby-identifier\">clone</span>\n<span class=\"ruby-identifier\">d</span>.<span class=\"ruby-identifier\">to_s</span>        <span class=\"ruby-comment\"># -&gt; &quot;Some text&quot;</span>\n</pre>\n"],["clone","REXML::Comment","REXML/Comment.html#method-i-clone","()",""],["clone","REXML::DocType","REXML/DocType.html#method-i-clone","()",""],["clone","REXML::Document","REXML/Document.html#method-i-clone","()","<p>Returns the new document resulting from executing <code>Document.new(self)</code>.  See Document.new.\n"],["clone","REXML::Element","REXML/Element.html#method-i-clone","()","<p>Returns a shallow copy of the element, containing the name and attributes, but not the parent or children: …\n"],["clone","REXML::Instruction","REXML/Instruction.html#method-i-clone","()",""],["clone","REXML::Text","REXML/Text.html#method-i-clone","()",""],["clone","REXML::XMLDecl","REXML/XMLDecl.html#method-i-clone","()",""],["collect","REXML::Elements","REXML/Elements.html#method-i-collect","( xpath=nil )","<p>Iterates over the elements; returns the array of block return values.\n<p>With no argument, iterates over …\n"],["comment","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-comment","(comment)","<p>Called when a comment is encountered. @p comment The content of the comment\n"],["comment","REXML::StreamListener","REXML/StreamListener.html#method-i-comment","(comment)","<p>Called when a comment is encountered. @p comment The content of the comment\n"],["comment?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-comment-3F","()","<p>Content: [ String text ]\n"],["comments","REXML::Element","REXML/Element.html#method-i-comments","()","<p>Returns a frozen array of the REXML::Comment children of the element:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root&gt;\n   ...</pre>\n"],["compare_language","REXML::Functions","REXML/Functions.html#method-c-compare_language","(lang1, lang2)",""],["concat","REXML::Functions","REXML/Functions.html#method-c-concat","( *objects )",""],["contains","REXML::Functions","REXML/Functions.html#method-c-contains","( string, test )","<p>Fixed by Mike Stok\n"],["context","REXML::DocType","REXML/DocType.html#method-i-context","()",""],["context","REXML::ParseException","REXML/ParseException.html#method-i-context","()",""],["context=","REXML::Functions","REXML/Functions.html#method-c-context-3D","(value)",""],["count","REXML::Functions","REXML/Functions.html#method-c-count","( node_set )","<p>Returns the size of the given list of nodes.\n"],["create_from","REXML::SourceFactory","REXML/SourceFactory.html#method-c-create_from","(arg)","<p>Generates a Source object @param arg Either a String, or an IO @return a Source, or nil if a bad argument …\n"],["current_line","REXML::IOSource","REXML/IOSource.html#method-i-current_line","()","<p>@return the current line in the source\n"],["current_line","REXML::Source","REXML/Source.html#method-i-current_line","()","<p>@return the current line in the source\n"],["dclone","REXML::DClonable","REXML/DClonable.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object types\n"],["deafen","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-deafen","( listener=nil, &blok )",""],["decode","REXML::Encoding","REXML/Encoding.html#method-i-decode","(string)",""],["deep_clone","REXML::Parent","REXML/Parent.html#method-i-deep_clone","()","<p>Deeply clones this object.  This creates a complete duplicate of this Parent, including all descendants. …\n"],["default","REXML::XMLDecl","REXML/XMLDecl.html#method-c-default","()","<p>Only use this if you do not want the XML declaration to be written; this object is ignored by the XML …\n"],["delete","REXML::Attributes","REXML/Attributes.html#method-i-delete","( attribute )","<p>Removes a specified attribute if it exists; returns the attributes&#39; element.\n<p>When string argument …\n"],["delete","REXML::Elements","REXML/Elements.html#method-i-delete","(element)","<p>Removes an element; returns the removed element, or <code>nil</code> if none removed.\n<p>With integer argument <code>index</code> given, …\n"],["delete","REXML::Parent","REXML/Parent.html#method-i-delete","( object )",""],["delete_all","REXML::Attributes","REXML/Attributes.html#method-i-delete_all","( name )","<p>Removes all attributes matching the given <code>name</code>; returns an array of the removed attributes:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">xml_string</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["delete_all","REXML::Elements","REXML/Elements.html#method-i-delete_all","( xpath )","<p>Removes all elements found via the given <code>xpath</code>; returns the array of removed elements, if any, else  …\n"],["delete_at","REXML::Parent","REXML/Parent.html#method-i-delete_at","( index )",""],["delete_attribute","REXML::Element","REXML/Element.html#method-i-delete_attribute","(key)","<p>Removes a named attribute if it exists; returns the removed attribute if found, otherwise <code>nil</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">e</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Element</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;foo&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["delete_element","REXML::Element","REXML/Element.html#method-i-delete_element","(element)","<p>Deletes a child element.\n<p>When 1-based integer argument <code>index</code> is given, removes and returns the child element …\n"],["delete_if","REXML::Parent","REXML/Parent.html#method-i-delete_if","( &block )",""],["delete_namespace","REXML::Element","REXML/Element.html#method-i-delete_namespace","(namespace=\"xmlns\")","<p>Removes a namespace from the element.\n<p>With no argument, removes the default namespace:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["doctype","REXML::Attribute","REXML/Attribute.html#method-i-doctype","()",""],["doctype","REXML::Document","REXML/Document.html#method-i-doctype","()","<p>Returns the DocType object for the document, if it exists, otherwise <code>nil</code>:\n\n<pre>d = REXML::Document.new(&#39;&lt;!DOCTYPE ...</pre>\n"],["doctype","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-doctype","(name, pub_sys, long_name, uri)","<p>Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  #  …\n"],["doctype","REXML::StreamListener","REXML/StreamListener.html#method-i-doctype","(name, pub_sys, long_name, uri)","<p>Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  #  …\n"],["doctype","REXML::Text","REXML/Text.html#method-i-doctype","()",""],["doctype?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-doctype-3F","()","<p>Content: [ String name, String pub_sys, String long_name, String uri ]\n"],["doctype_end","REXML::StreamListener","REXML/StreamListener.html#method-i-doctype_end","()","<p>Called when the doctype is done\n"],["document","REXML::Child","REXML/Child.html#method-i-document","()","<p>Returns &mdash; the document this child belongs to, or nil if this child\n\n<p>belongs to no document\n"],["document","REXML::Document","REXML/Document.html#method-i-document","()",""],["document","REXML::Element","REXML/Element.html#method-i-document","()","<p>If the element is part of a document, returns that document:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["done?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-done-3F","()",""],["dowrite","REXML::XMLDecl","REXML/XMLDecl.html#method-i-dowrite","()",""],["dump","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-dump","()",""],["each","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-each","(&block)","<p>Iterate over the key/value pairs:\n\n<pre>attlist_decl.each { |attribute_name, attribute_value| ... }</pre>\n"],["each","REXML::Attributes","REXML/Attributes.html#method-i-each","()","<p>Calls the given block with each expanded-name/value pair:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root xmlns:foo=&quot;http://foo&quot; ...</pre>\n"],["each","REXML::Elements","REXML/Elements.html#method-i-each","( xpath=nil )","<p>Iterates over the elements.\n<p>With no argument, calls the block with each element:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-identifier\">xml_string</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each","REXML::Light::Node","REXML/Light/Node.html#method-i-each","()",""],["each","REXML::Parent","REXML/Parent.html#method-i-each","(&block)",""],["each","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-each","()",""],["each","REXML::QuickPath","REXML/QuickPath.html#method-c-each","(element, path, namespaces=EMPTY_HASH, &block)",""],["each","REXML::XPath","REXML/XPath.html#method-c-each","(element, path=nil, namespaces=nil, variables={}, options={}, &block)","<p>Iterates over nodes that match the given path, calling the supplied block with the match.\n<p>element &mdash; The …\n"],["each_attribute","REXML::Attributes","REXML/Attributes.html#method-i-each_attribute","()","<p>Calls the given block with each REXML::Attribute object:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root xmlns:foo=&quot;http://foo&quot; ...</pre>\n"],["each_child","REXML::Parent","REXML/Parent.html#method-i-each_child","(&block)",""],["each_element","REXML::Element","REXML/Element.html#method-i-each_element","( xpath=nil )","<p>Calls the given block with each child element:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b&gt;b&lt;/b&gt;&lt;c&gt;b&lt;/c&gt;&lt;d&gt;d&lt;/d&gt;&lt;e/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each_element_with_attribute","REXML::Element","REXML/Element.html#method-i-each_element_with_attribute","( key, value=nil, max=0, name=nil )","<p>Calls the given block with each child element that meets given criteria.\n<p>When only string argument <code>attr_name</code> …\n"],["each_element_with_text","REXML::Element","REXML/Element.html#method-i-each_element_with_text","( text=nil, max=0, name=nil )","<p>Calls the given block with each child element that meets given criteria.\n<p>With no arguments, calls the …\n"],["each_index","REXML::Parent","REXML/Parent.html#method-i-each_index","( &block )",""],["each_recursive","REXML::Node","REXML/Node.html#method-i-each_recursive","()","<p>Visit all subnodes of <code>self</code> recursively\n"],["element=","REXML::Attribute","REXML/Attribute.html#method-i-element-3D","( element )","<p>Sets the element of which this object is an attribute.  Normally, this is not directly called.\n<p>Returns …\n"],["elementdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-elementdecl","(content)","<p>&lt;!ELEMENT …&gt;\n"],["elementdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-elementdecl","(content)","<p>&lt;!ELEMENT …&gt;\n"],["elementdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-elementdecl-3F","()","<p>Content: [ String text ]\n"],["empty?","REXML::Elements","REXML/Elements.html#method-i-empty-3F","()","<p>Returns <code>true</code> if there are no children, <code>false</code> otherwise.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>)\n<span class=\"ruby-identifier\">d</span>.<span class=\"ruby-identifier\">elements</span>.<span class=\"ruby-identifier\">empty?</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["empty?","REXML::IOSource","REXML/IOSource.html#method-i-empty-3F","()",""],["empty?","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-empty-3F","()","<p>Returns true if there are no more events\n"],["empty?","REXML::Source","REXML/Source.html#method-i-empty-3F","()","<p>@return true if the Source is exhausted\n"],["empty?","REXML::Text","REXML/Text.html#method-i-empty-3F","()",""],["encode","REXML::Encoding","REXML/Encoding.html#method-i-encode","(string)",""],["encoding","REXML::Document","REXML/Document.html#method-i-encoding","()","<p>Returns the XMLDecl encoding of the document, if it has been set, otherwise the default encoding:\n\n<pre>d = ...</pre>\n"],["encoding=","REXML::Encoding","REXML/Encoding.html#method-i-encoding-3D","(encoding)",""],["encoding=","REXML::Source","REXML/Source.html#method-i-encoding-3D","(enc)","<p>Inherited from Encoding Overridden to support optimized en/decoding\n"],["encoding=","REXML::XMLDecl","REXML/XMLDecl.html#method-i-encoding-3D","( enc )",""],["end_document","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_document","()",""],["end_element","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_element","(uri, localname, qname)",""],["end_element?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-end_element-3F","()","<p>Content: [ String tag_name ]\n"],["end_prefix_mapping","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_prefix_mapping","(prefix)",""],["ensure_buffer","REXML::IOSource","REXML/IOSource.html#method-i-ensure_buffer","()",""],["ensure_buffer","REXML::Source","REXML/Source.html#method-i-ensure_buffer","()",""],["entity","REXML::DocType","REXML/DocType.html#method-i-entity","( name )",""],["entity","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-entity","( reference, entities )",""],["entity","REXML::StreamListener","REXML/StreamListener.html#method-i-entity","(content)","<p>Called when %foo; is encountered in a doctype declaration. @p content “foo”\n"],["entity?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-entity-3F","()","<p>Content: [ String text ]\n"],["entity_expansion_limit","REXML::Document","REXML/Document.html#method-c-entity_expansion_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10000.\n<p>Deprecated. Use REXML::Security.entity_expansion_limit= …\n"],["entity_expansion_limit","REXML::Security","REXML/Security.html#method-c-entity_expansion_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10000.\n"],["entity_expansion_limit=","REXML::Document","REXML/Document.html#method-c-entity_expansion_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10000.\n<p>Deprecated. Use REXML::Security.entity_expansion_limit= …\n"],["entity_expansion_limit=","REXML::Security","REXML/Security.html#method-c-entity_expansion_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10000.\n"],["entity_expansion_text_limit","REXML::Document","REXML/Document.html#method-c-entity_expansion_text_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10240.\n<p>Deprecated. Use REXML::Security.entity_expansion_text_limit …\n"],["entity_expansion_text_limit","REXML::Security","REXML/Security.html#method-c-entity_expansion_text_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10240.\n"],["entity_expansion_text_limit=","REXML::Document","REXML/Document.html#method-c-entity_expansion_text_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10240.\n<p>Deprecated. Use REXML::Security.entity_expansion_text_limit= …\n"],["entity_expansion_text_limit=","REXML::Security","REXML/Security.html#method-c-entity_expansion_text_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10240.\n"],["entitydecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-entitydecl","(declaration)","<p>&lt;!ENTITY …&gt; The argument passed to this method is an array of the entity declaration.  It can …\n"],["entitydecl","REXML::StreamListener","REXML/StreamListener.html#method-i-entitydecl","(content)","<p>&lt;!ENTITY …&gt; The argument passed to this method is an array of the entity declaration.  It can …\n"],["entitydecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-entitydecl-3F","()","<p>Due to the wonders of DTDs, an entity declaration can be just about anything.  There&#39;s no way to …\n"],["error?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-error-3F","()",""],["event_type","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-event_type","()",""],["expand","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-expand","(path_or_parsed)",""],["expand_ref_in","REXML::Validation::State","REXML/Validation/State.html#method-i-expand_ref_in","( arry, ind )",""],["expanded_name","REXML::Document","REXML/Document.html#method-i-expanded_name","()","<p>Returns an empty string.\n"],["expected","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-expected","()",""],["expected","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-expected","()",""],["expected","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-expected","()",""],["expected","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-expected","()",""],["expected","REXML::Validation::State","REXML/Validation/State.html#method-i-expected","()",""],["expected","REXML::Validation::ZeroOrMore","REXML/Validation/ZeroOrMore.html#method-i-expected","()",""],["false","REXML::Functions","REXML/Functions.html#method-c-false","( )","<p>UNTESTED\n"],["filter","REXML::QuickPath","REXML/QuickPath.html#method-c-filter","(elements, path)","<p>Given an array of nodes it filters the array based on the path. The result is that when this method returns, …\n"],["find_first_recursive","REXML::Node","REXML/Node.html#method-i-find_first_recursive","()","<p>Find (and return) first subnode (recursively) for which the block evaluates to true. Returns <code>nil</code> if none …\n"],["first","REXML::QuickPath","REXML/QuickPath.html#method-c-first","(element, path, namespaces=EMPTY_HASH)",""],["first","REXML::XPath","REXML/XPath.html#method-c-first","(element, path=nil, namespaces=nil, variables={}, options={})","<p>Finds and returns the first node that matches the supplied xpath.\n<p>element &mdash; The context element\n<p>path &mdash; The …\n"],["first","REXML::XPathParser","REXML/XPathParser.html#method-i-first","( path_stack, node )","<p>Performs a depth-first (document order) XPath search, and returns the first match.  This is the fastest, …\n"],["floor","REXML::Functions","REXML/Functions.html#method-c-floor","( number )",""],["fully_expanded_name","REXML::Namespace","REXML/Namespace.html#method-i-fully_expanded_name","()","<p>Fully expand the name, even if the prefix wasn&#39;t specified in the source file.\n"],["function","REXML::QuickPath","REXML/QuickPath.html#method-c-function","( elements, fname, rest )",""],["generate_event","REXML::Validation::State","REXML/Validation/State.html#method-i-generate_event","( event )",""],["get_attribute","REXML::Attributes","REXML/Attributes.html#method-i-get_attribute","( name )","<p>Returns the REXML::Attribute object for the given <code>name</code>:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root xmlns:foo=&quot;http://foo&quot; ...</pre>\n"],["get_attribute_ns","REXML::Attributes","REXML/Attributes.html#method-i-get_attribute_ns","(namespace, name)","<p>Returns the REXML::Attribute object among the attributes that matches the given <code>namespace</code> and <code>name</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">xml_string</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["get_elements","REXML::Element","REXML/Element.html#method-i-get_elements","( xpath )","<p>Returns an array of the elements that match the given <code>xpath</code>:\n\n<pre>xml_string = &lt;&lt;-EOT\n&lt;root&gt;\n  &lt;a level=&#39;1&#39;&gt; ...</pre>\n"],["get_first","REXML::XPathParser","REXML/XPathParser.html#method-i-get_first","(path, nodeset)",""],["get_namespace","REXML::Functions","REXML/Functions.html#method-c-get_namespace","( node_set = nil )","<p>Helper method.\n"],["get_text","REXML::Element","REXML/Element.html#method-i-get_text","(path = nil)","<p>Returns the first text node child in a specified element, if it exists, <code>nil</code> otherwise.\n<p>With no argument, …\n"],["has_attributes?","REXML::Element","REXML/Element.html#method-i-has_attributes-3F","()","<p>Returns <code>true</code> if the element has attributes, <code>false</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;root&gt;&lt;a attr=&quot;val&quot;/&gt;&lt;b/&gt;&lt;/root&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["has_elements?","REXML::Element","REXML/Element.html#method-i-has_elements-3F","()","<p>Returns <code>true</code> if the element has one or more element children, <code>false</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["has_name?","REXML::Light::Node","REXML/Light/Node.html#method-i-has_name-3F","( name, namespace = '' )",""],["has_name?","REXML::Namespace","REXML/Namespace.html#method-i-has_name-3F","( other, ns=nil )","<p>Compares names optionally WITH namespaces\n"],["has_next?","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-has_next-3F","()","<p>Returns true if there are more events.  Synonymous with !empty?\n"],["has_text?","REXML::Element","REXML/Element.html#method-i-has_text-3F","()","<p>Returns <code>true</code> if the element has one or more text noded, <code>false</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["hash","REXML::Attribute","REXML/Attribute.html#method-i-hash","()","<p>Creates (and returns) a hash from both the name and value\n"],["id","REXML::Functions","REXML/Functions.html#method-c-id","( object )","<p>Since REXML is non-validating, this method is not implemented as it requires a DTD\n"],["ignore_whitespace_nodes","REXML::Element","REXML/Element.html#method-i-ignore_whitespace_nodes","()","<p>Returns <code>true</code> if whitespace nodes are ignored for the element.\n<p>See Element Context.\n"],["include?","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-include-3F","(key)","<p>Whether an attlist declaration includes the given attribute definition\n\n<pre>if attlist_decl.include? &quot;xmlns:foobar&quot;</pre>\n"],["indent","REXML::Node","REXML/Node.html#method-i-indent","(to, ind)",""],["indent_text","REXML::Text","REXML/Text.html#method-i-indent_text","(string, level=1, style=\"\\t\", indentfirstline=true)",""],["index","REXML::Elements","REXML/Elements.html#method-i-index","(element)","<p>Returns the 1-based index of the given <code>element</code>, if found; otherwise, returns -1:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-identifier\">xml_string</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["index","REXML::Parent","REXML/Parent.html#method-i-index","( child )","<p>Fetches the index of a given child @param child the child to get the index of @return the index of the …\n"],["index_in_parent","REXML::Node","REXML/Node.html#method-i-index_in_parent","()","<p>Returns the position that <code>self</code> holds in its parent&#39;s array, indexed from 1.\n"],["inject","REXML::Elements","REXML/Elements.html#method-i-inject","( xpath=nil, initial=nil )","<p>Calls the block with elements; returns the last block return value.\n<p>With no argument, iterates over the …\n"],["insert_after","REXML::Parent","REXML/Parent.html#method-i-insert_after","( child1, child2 )","<p>Inserts an child after another child @param child1 this is either an xpath or an Element.  If an Element …\n"],["insert_before","REXML::Parent","REXML/Parent.html#method-i-insert_before","( child1, child2 )","<p>Inserts an child before another child @param child1 this is either an xpath or an Element.  If an Element …\n"],["inspect","REXML::Attribute","REXML/Attribute.html#method-i-inspect","()",""],["inspect","REXML::Element","REXML/Element.html#method-i-inspect","()","<p>Returns a string representation of the element.\n<p>For an element with no attributes and no children, shows …\n"],["inspect","REXML::Instruction","REXML/Instruction.html#method-i-inspect","()",""],["inspect","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-inspect","()",""],["inspect","REXML::Text","REXML/Text.html#method-i-inspect","()",""],["inspect","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-inspect","()",""],["inspect","REXML::Validation::Event","REXML/Validation/Event.html#method-i-inspect","()",""],["inspect","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-inspect","()",""],["inspect","REXML::Validation::Ref","REXML/Validation/Ref.html#method-i-inspect","()",""],["inspect","REXML::Validation::State","REXML/Validation/State.html#method-i-inspect","()",""],["inspect","REXML::XMLDecl","REXML/XMLDecl.html#method-i-inspect","()",""],["instruction","REXML::StreamListener","REXML/StreamListener.html#method-i-instruction","(name, instruction)","<p>Called when an instruction is encountered.  EG: &lt;?xsl sheet=&#39;foo&#39;?&gt; @p name the instruction …\n"],["instruction?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-instruction-3F","()","<p>Content: [ String text ]\n"],["instructions","REXML::Element","REXML/Element.html#method-i-instructions","()","<p>Returns a frozen array of the REXML::Instruction children of the element:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root&gt; ...</pre>\n"],["lang","REXML::Functions","REXML/Functions.html#method-c-lang","( language )","<p>UNTESTED\n"],["last","REXML::Functions","REXML/Functions.html#method-c-last","( )","<p>Returns the last node of the given list of nodes.\n"],["length","REXML::Attributes","REXML/Attributes.html#method-i-length","()","<p>Returns the count of attributes:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root xmlns:foo=&quot;http://foo&quot; xmlns:bar=&quot;http://bar&quot;&gt; ...</pre>\n"],["length","REXML::Parent","REXML/Parent.html#method-i-length","()",""],["line","REXML::ParseException","REXML/ParseException.html#method-i-line","()",""],["listen","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-listen","( *args, &blok )","<p>Listen arguments:\n<p>Symbol, Array, Block\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Listen</span> <span class=\"ruby-identifier\">to</span> <span class=\"ruby-constant\">Symbol</span> <span class=\"ruby-identifier\">events</span> <span class=\"ruby-identifier\">on</span> <span class=\"ruby-constant\">Array</span> <span class=\"ruby-identifier\">elements</span>\n</pre>\n"],["local_name","REXML::Functions","REXML/Functions.html#method-c-local_name","(node_set=nil)",""],["local_name","REXML::Light::Node","REXML/Light/Node.html#method-i-local_name","()",""],["local_name=","REXML::Light::Node","REXML/Light/Node.html#method-i-local_name-3D","( name_str )",""],["match","REXML::IOSource","REXML/IOSource.html#method-i-match","( pattern, cons=false )","<p>Note: When specifying a string for &#39;pattern&#39;, it must not include &#39;&gt;&#39; except in the …\n"],["match","REXML::QuickPath","REXML/QuickPath.html#method-c-match","(element, path, namespaces=EMPTY_HASH)",""],["match","REXML::Source","REXML/Source.html#method-i-match","(pattern, cons=false)",""],["match","REXML::XPath","REXML/XPath.html#method-c-match","(element, path=nil, namespaces=nil, variables={}, options={})","<p>Returns an array of nodes matching a given XPath.\n"],["match","REXML::XPathParser","REXML/XPathParser.html#method-i-match","(path_stack, nodeset)",""],["matches?","REXML::Entity","REXML/Entity.html#method-c-matches-3F","(string)","<p>Evaluates whether the given string matches an entity definition, returning true if so, and false otherwise. …\n"],["matches?","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-matches-3F","(event)",""],["matches?","REXML::Validation::Sequence","REXML/Validation/Sequence.html#method-i-matches-3F","(event)",""],["method_missing","REXML::QuickPath","REXML/QuickPath.html#method-c-method_missing","( id, *args )",""],["name","REXML::Document","REXML/Document.html#method-i-name","()",""],["name","REXML::Functions","REXML/Functions.html#method-c-name","( node_set=nil )",""],["name","REXML::Light::Node","REXML/Light/Node.html#method-i-name","()",""],["name","REXML::NotationDecl","REXML/NotationDecl.html#method-i-name","()","<p>This method retrieves the name of the notation.\n<p>Method contributed by Henrik Martensson\n"],["name","REXML::QuickPath","REXML/QuickPath.html#method-c-name","()",""],["name=","REXML::Light::Node","REXML/Light/Node.html#method-i-name-3D","( name_str, ns=nil )",""],["name=","REXML::Namespace","REXML/Namespace.html#method-i-name-3D","( name )","<p>Sets the name and the expanded name\n"],["namespace","REXML::Attribute","REXML/Attribute.html#method-i-namespace","(arg=nil)","<p>Returns the namespace URL, if defined, or nil otherwise\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">e</span> = <span class=\"ruby-constant\">Element</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot;el&quot;</span>)\n<span class=\"ruby-identifier\">e</span>.<span class=\"ruby-identifier\">add_namespace</span>(<span class=\"ruby-string\">&quot;ns&quot;</span>, <span class=\"ruby-string\">&quot;http://url&quot;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["namespace","REXML::Element","REXML/Element.html#method-i-namespace","(prefix=nil)","<p>Returns the string namespace URI for the element, possibly deriving from one of its ancestors.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">xml_string</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["namespace","REXML::Light::Node","REXML/Light/Node.html#method-i-namespace","( prefix=prefix() )",""],["namespace=","REXML::Light::Node","REXML/Light/Node.html#method-i-namespace-3D","( namespace )",""],["namespace_context","REXML::Functions","REXML/Functions.html#method-c-namespace_context","()",""],["namespace_context=","REXML::Functions","REXML/Functions.html#method-c-namespace_context-3D","(x)",""],["namespace_uri","REXML::Functions","REXML/Functions.html#method-c-namespace_uri","( node_set=nil )",""],["namespaces","REXML::Attributes","REXML/Attributes.html#method-i-namespaces","()","<p>Returns a hash of name/value pairs for the namespaces:\n\n<pre>xml_string = &#39;&lt;a xmlns=&quot;foo&quot; xmlns:x=&quot;bar&quot; xmlns:y=&quot;twee&quot; ...</pre>\n"],["namespaces","REXML::Element","REXML/Element.html#method-i-namespaces","()","<p>Returns a hash of all defined namespaces in the element and its ancestors:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root&gt; ...</pre>\n"],["namespaces=","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-namespaces-3D","( namespaces )",""],["namespaces=","REXML::XPathParser","REXML/XPathParser.html#method-i-namespaces-3D","( namespaces={} )",""],["new","REXML::AttlistDecl","REXML/AttlistDecl.html#method-c-new","(source)","<p>Create an AttlistDecl, pulling the information from a Source.  Notice that this isn&#39;t very convenient; …\n"],["new","REXML::Attribute","REXML/Attribute.html#method-c-new","( first, second=nil, parent=nil )","<p>Constructor. FIXME: The parser doesn&#39;t catch illegal characters in attributes\n<p>first &mdash; Either: an Attribute …\n"],["new","REXML::Attributes","REXML/Attributes.html#method-c-new","(element)","<p>Creates and returns a new REXML::Attributes object. The element given by argument <code>element</code> is stored, …\n"],["new","REXML::CData","REXML/CData.html#method-c-new","( first, whitespace=true, parent=nil )","\n<pre>Constructor.  CData is data between &lt;![CDATA[ ... ]]&gt;</pre>\n<p><em>Examples</em>\n\n<pre>CData.new( source )\nCData.new( &quot;Here is ...</pre>\n"],["new","REXML::Child","REXML/Child.html#method-c-new","( parent = nil )","<p>Constructor.  Any inheritors of this class should call super to make sure this method is called.\n<p>parent … &mdash; "],["new","REXML::Comment","REXML/Comment.html#method-c-new","( first, second = nil )","<p>Constructor.  The first argument can be one of three types: @param first If String, the contents of this …\n"],["new","REXML::DTD::ElementDecl","REXML/DTD/ElementDecl.html#method-c-new","(match)","<p>s*(((([“‘]).*?5)|*)*?)(/)?&gt;/um, true)\n"],["new","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-c-new","(src)","<p>&lt;!ENTITY name SYSTEM “…”&gt; &lt;!ENTITY name “…”&gt;\n"],["new","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-c-new","(src)",""],["new","REXML::Declaration","REXML/Declaration.html#method-c-new","(src)",""],["new","REXML::DocType","REXML/DocType.html#method-c-new","( first, parent=nil )","<p>Constructor\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">dt</span> = <span class=\"ruby-constant\">DocType</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&#39;foo&#39;</span>, <span class=\"ruby-string\">&#39;-//I/Hate/External/IDs&#39;</span> )\n<span class=\"ruby-comment\"># &lt;!DOCTYPE foo &#39;-//I/Hate/External/IDs&#39;&gt; ...</span>\n</pre>\n"],["new","REXML::Document","REXML/Document.html#method-c-new","( source = nil, context = {} )","<p>Returns a new REXML::Document object.\n<p>When no arguments are given, returns an empty document:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["new","REXML::Element","REXML/Element.html#method-c-new","( arg = UNDEFINED, parent=nil, context=nil )","<p>Returns a new REXML::Element object.\n<p>When no arguments are given, returns an element with name <code>&#39;UNDEFINED&#39;</code> …\n"],["new","REXML::ElementDecl","REXML/ElementDecl.html#method-c-new","( src )",""],["new","REXML::Elements","REXML/Elements.html#method-c-new","(parent)","<p>Returns a new Elements object with the given <code>parent</code>. Does <em>not</em> assign <code>parent.elements = self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-identifier\">xml_string</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["new","REXML::Entity","REXML/Entity.html#method-c-new","(stream, value=nil, parent=nil, reference=false)","<p>Create a new entity.  Simple entities can be constructed by passing a name, value to the constructor; …\n"],["new","REXML::ExternalEntity","REXML/ExternalEntity.html#method-c-new","( src )",""],["new","REXML::Formatters::Default","REXML/Formatters/Default.html#method-c-new","( ie_hack=false )","<p>Prints out the XML document with no formatting – except if ie_hack is set.\n<p>ie_hack &mdash; If set to true, then …\n\n"],["new","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-c-new","( indentation=2, ie_hack=false )","<p>Create a new pretty printer.\n<p>output &mdash; An object implementing &#39;&lt;&lt;(String)&#39;, to which the output …\n"],["new","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-c-new","( indentation=2, ie_hack=false )",""],["new","REXML::IOSource","REXML/IOSource.html#method-c-new","(arg, block_size=500, encoding=nil)","<p>block_size has been deprecated\n"],["new","REXML::Instruction","REXML/Instruction.html#method-c-new","(target, content=nil)","<p>Constructs a new Instruction @param target can be one of a number of things.  If String, then the target …\n"],["new","REXML::Light::Node","REXML/Light/Node.html#method-c-new","(node=nil)","<p>Create a new element.\n"],["new","REXML::NotationDecl","REXML/NotationDecl.html#method-c-new","(name, middle, pub, sys)",""],["new","REXML::Output","REXML/Output.html#method-c-new","(real_IO, encd=\"iso-8859-1\")",""],["new","REXML::Parent","REXML/Parent.html#method-c-new","(parent=nil)","<p>Constructor @param parent if supplied, will be set as the parent of this object\n"],["new","REXML::ParseException","REXML/ParseException.html#method-c-new","( message, source=nil, parser=nil, exception=nil )",""],["new","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-c-new","( source )",""],["new","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-c-new","(stream)",""],["new","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-c-new","(arg)","<p>The type of this event.  Will be one of :tag_start, :tag_end, :text, :processing_instruction, :comment, …\n"],["new","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-c-new","(stream)",""],["new","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-c-new","(source)",""],["new","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-c-new","(source, listener)",""],["new","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-c-new","( source, build_context = Document.new )",""],["new","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-c-new","(stream)",""],["new","REXML::ReferenceWriter","REXML/ReferenceWriter.html#method-c-new","(id_type, public_id_literal, system_literal, context=nil)",""],["new","REXML::Source","REXML/Source.html#method-c-new","(arg, encoding=nil)","<p>Constructor @param arg must be a String, and should be a valid XML document @param encoding if non-null, …\n"],["new","REXML::Text","REXML/Text.html#method-c-new","(arg, respect_whitespace=false, parent=nil, raw=nil, entity_filter=nil, illegal=NEEDS_A_SECOND_CHECK )","<p>Constructor <code>arg</code> if a String, the content is set to the String.  If a Text, the object is shallowly cloned. …\n"],["new","REXML::UndefinedNamespaceException","REXML/UndefinedNamespaceException.html#method-c-new","( prefix, source, parser )",""],["new","REXML::Validation::Choice","REXML/Validation/Choice.html#method-c-new","(context)",""],["new","REXML::Validation::Event","REXML/Validation/Event.html#method-c-new","(event_type, event_arg=nil )",""],["new","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-c-new","(context)",""],["new","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-c-new","(context)",""],["new","REXML::Validation::Ref","REXML/Validation/Ref.html#method-c-new","(value)",""],["new","REXML::Validation::RelaxNG","REXML/Validation/RelaxNG.html#method-c-new","(source)","<p>FIXME: Namespaces\n"],["new","REXML::Validation::State","REXML/Validation/State.html#method-c-new","( context )",""],["new","REXML::Validation::ValidationException","REXML/Validation/ValidationException.html#method-c-new","(msg)",""],["new","REXML::XMLDecl","REXML/XMLDecl.html#method-c-new","(version=DEFAULT_VERSION, encoding=nil, standalone=nil)",""],["new","REXML::XPathNode","REXML/XPathNode.html#method-c-new","(node, context=nil)",""],["new","REXML::XPathParser","REXML/XPathParser.html#method-c-new","(strict: false)",""],["next","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-next","( event )",""],["next","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-next","( event )",""],["next","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-next","( event )",""],["next","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-next","( event )",""],["next","REXML::Validation::State","REXML/Validation/State.html#method-i-next","( event )",""],["next","REXML::Validation::ZeroOrMore","REXML/Validation/ZeroOrMore.html#method-i-next","( event )",""],["next_current","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-next_current","( event )",""],["next_element","REXML::Element","REXML/Element.html#method-i-next_element","()","<p>Returns the next sibling that is an element if it exists, <code>niL</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["next_sibling=","REXML::Child","REXML/Child.html#method-i-next_sibling-3D","( other )","<p>Sets the next sibling of this child.  This can be used to insert a child after some other child.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> = <span class=\"ruby-constant\">Element</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot;a&quot;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["next_sibling_node","REXML::Node","REXML/Node.html#method-i-next_sibling_node","()","<p>@return the next sibling (nil if unset)\n"],["node_type","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-node_type","()",""],["node_type","REXML::Attribute","REXML/Attribute.html#method-i-node_type","()",""],["node_type","REXML::Comment","REXML/Comment.html#method-i-node_type","()",""],["node_type","REXML::DocType","REXML/DocType.html#method-i-node_type","()",""],["node_type","REXML::Document","REXML/Document.html#method-i-node_type","()","<p>Returns the symbol <code>:document</code>.\n"],["node_type","REXML::Element","REXML/Element.html#method-i-node_type","()","<p>Returns symbol <code>:element</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;a/&gt;&#39;</span>)\n<span class=\"ruby-identifier\">a</span> = <span class=\"ruby-identifier\">d</span>.<span class=\"ruby-identifier\">root</span>  <span class=\"ruby-comment\"># =&gt; &lt;a/&gt;</span>\n<span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">node_type</span> <span class=\"ruby-comment\"># =&gt; :element</span>\n</pre>\n"],["node_type","REXML::Instruction","REXML/Instruction.html#method-i-node_type","()",""],["node_type","REXML::Light::Node","REXML/Light/Node.html#method-i-node_type","()",""],["node_type","REXML::Text","REXML/Text.html#method-i-node_type","()",""],["node_type","REXML::XMLDecl","REXML/XMLDecl.html#method-i-node_type","()",""],["normalize","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-normalize","( input, entities=nil, entity_filter=nil )","<p>Escapes all possible entities\n"],["normalize_space","REXML::Functions","REXML/Functions.html#method-c-normalize_space","( string=nil )",""],["normalized","REXML::Entity","REXML/Entity.html#method-i-normalized","()","<p>Returns the value of this entity unprocessed – raw.  This is the normalized value; that is, with all …\n"],["normalized=","REXML::Attribute","REXML/Attribute.html#method-i-normalized-3D","(new_normalized)","<p>The normalized value of this attribute.  That is, the attribute with entities intact.\n"],["not","REXML::Functions","REXML/Functions.html#method-c-not","( object )","<p>UNTESTED\n"],["notation","REXML::DocType","REXML/DocType.html#method-i-notation","(name)","<p>Retrieves a named notation. Only notations declared in the internal DTD subset can be retrieved.\n<p>Method …\n"],["notationdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-notationdecl","(name, public_or_system, public_id, system_id)","<p>&lt;!NOTATION …&gt;\n"],["notationdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-notationdecl","(content)","<p>&lt;!NOTATION …&gt;\n"],["notationdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-notationdecl-3F","()","<p>Content: [ String text ]\n"],["notations","REXML::DocType","REXML/DocType.html#method-i-notations","()","<p>This method returns a list of notations that have been declared in the <em>internal</em> DTD subset. Notations …\n"],["nowrite","REXML::XMLDecl","REXML/XMLDecl.html#method-i-nowrite","()",""],["number","REXML::Functions","REXML/Functions.html#method-c-number","(object=@@context[:node])","<p>a string that consists of optional whitespace followed by an optional minus sign followed by a Number …\n"],["old_enc=","REXML::XMLDecl","REXML/XMLDecl.html#method-i-old_enc-3D","( enc )",""],["parent","REXML::Elements","REXML/Elements.html#method-i-parent","()","<p>Returns the parent element cited in creating the Elements object. This element is also the default starting …\n"],["parent","REXML::Light::Node","REXML/Light/Node.html#method-i-parent","()",""],["parent=","REXML::Child","REXML/Child.html#method-i-parent-3D","( other )","<p>Sets the parent of this child to the supplied argument.\n<p>other &mdash; Must be a Parent object.  If this object …\n"],["parent=","REXML::Entity","REXML/Entity.html#method-i-parent-3D","(other)",""],["parent=","REXML::Light::Node","REXML/Light/Node.html#method-i-parent-3D","( node )",""],["parent=","REXML::Text","REXML/Text.html#method-i-parent-3D","(parent)",""],["parent?","REXML::Node","REXML/Node.html#method-i-parent-3F","()",""],["parent?","REXML::Parent","REXML/Parent.html#method-i-parent-3F","()",""],["parse","REXML::DTD::Parser","REXML/DTD/Parser.html#method-c-parse","( input )",""],["parse","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-parse","()",""],["parse","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-parse","()",""],["parse","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-i-parse","()",""],["parse","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-i-parse","()",""],["parse","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-parse","()",""],["parse","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-parse","(path)",""],["parse","REXML::XPathParser","REXML/XPathParser.html#method-i-parse","(path, nodeset)",""],["parse_args","REXML::QuickPath","REXML/QuickPath.html#method-c-parse_args","( element, string )",""],["parse_helper","REXML::DTD::Parser","REXML/DTD/Parser.html#method-c-parse_helper","( input )","<p>Takes a String and parses it out\n"],["parse_source","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-c-parse_source","(source, listener)",""],["parse_source","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-c-parse_source","(source, listener)",""],["parse_stream","REXML::Document","REXML/Document.html#method-c-parse_stream","( source, listener )",""],["peek","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-peek","(depth=0)","<p>Peek at the <code>depth</code> event in the stack.  The first element on the stack is at depth 0.  If <code>depth</code> is -1, …\n"],["peek","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-peek","(depth=0)",""],["position","REXML::Functions","REXML/Functions.html#method-c-position","( )",""],["position","REXML::ParseException","REXML/ParseException.html#method-i-position","()",""],["position","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-position","()",""],["position","REXML::Source","REXML/Source.html#method-i-position","()",""],["position","REXML::XPathNode","REXML/XPathNode.html#method-i-position","()",""],["position=","REXML::Source","REXML/Source.html#method-i-position-3D","(pos)",""],["preciate_to_string","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-preciate_to_string","(parsed, &block)","<p>For backward compatibility\n"],["predicate","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-predicate","(path)",""],["predicate","REXML::QuickPath","REXML/QuickPath.html#method-c-predicate","( elements, path )","<p>A predicate filters a node-set with respect to an axis to produce a new node-set. For each node in the …\n"],["predicate","REXML::XPathParser","REXML/XPathParser.html#method-i-predicate","(path, nodeset)",""],["predicate_to_path","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-predicate_to_path","(parsed, &block)",""],["prefix","REXML::Attribute","REXML/Attribute.html#method-i-prefix","()","<p>Returns the namespace of the attribute.\n\n<pre>e = Element.new( &quot;elns:myelement&quot; )\ne.add_attribute( &quot;nsa:a&quot;, ...</pre>\n"],["prefix","REXML::Light::Node","REXML/Light/Node.html#method-i-prefix","( namespace=nil )",""],["prefixes","REXML::Attributes","REXML/Attributes.html#method-i-prefixes","()","<p>Returns an array of prefix strings in the attributes. The array does not include the default namespace …\n"],["prefixes","REXML::Element","REXML/Element.html#method-i-prefixes","()","<p>Returns an array of the string prefixes (names) of all defined namespaces in the element and its ancestors: …\n"],["previous=","REXML::Validation::State","REXML/Validation/State.html#method-i-previous-3D","( previous )",""],["previous_element","REXML::Element","REXML/Element.html#method-i-previous_element","()","<p>Returns the previous sibling that is an element if it exists, <code>niL</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["previous_sibling=","REXML::Child","REXML/Child.html#method-i-previous_sibling-3D","(other)","<p>Sets the previous sibling of this child.  This can be used to insert a child before some other child. …\n"],["previous_sibling_node","REXML::Node","REXML/Node.html#method-i-previous_sibling_node","()","<p>@return the previous sibling (nil if unset)\n"],["processing_instruction","REXML::Functions","REXML/Functions.html#method-c-processing_instruction","( node )",""],["processing_instruction","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-processing_instruction","(target, data)",""],["progress","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-progress","(position)",""],["public","REXML::DocType","REXML/DocType.html#method-i-public","()","<p>This method retrieves the public identifier identifying the document&#39;s DTD.\n<p>Method contributed by …\n"],["pull","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-pull","()","<p>Returns the next event.  This is a <code>PullEvent</code> object.\n"],["pull","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-pull","()",""],["push","REXML::Parent","REXML/Parent.html#method-i-push","( object )",""],["raw","REXML::Element","REXML/Element.html#method-i-raw","()","<p>Returns <code>true</code> if raw mode is set for the element.\n<p>See Element Context.\n<p>The evaluation is tested against …\n"],["read","REXML::IOSource","REXML/IOSource.html#method-i-read","(term = nil)",""],["read","REXML::Source","REXML/Source.html#method-i-read","(term = nil)",""],["read_until","REXML::IOSource","REXML/IOSource.html#method-i-read_until","(term)",""],["read_until","REXML::Source","REXML/Source.html#method-i-read_until","(term)",""],["receive","REXML::Validation::RelaxNG","REXML/Validation/RelaxNG.html#method-i-receive","(event)",""],["record_entity_expansion","REXML::Document","REXML/Document.html#method-i-record_entity_expansion","()",""],["remove","REXML::Attribute","REXML/Attribute.html#method-i-remove","()","<p>Removes this Attribute from the tree, and returns true if successful\n<p>This method is usually not called …\n"],["remove","REXML::Child","REXML/Child.html#method-i-remove","()","<p>Removes this child from the parent.\n<p>Returns &mdash; self\n\n"],["replace_child","REXML::Parent","REXML/Parent.html#method-i-replace_child","( to_replace, replacement )","<p>Replaces one child with another, making sure the nodelist is correct @param to_replace the child to replace …\n"],["replace_with","REXML::Child","REXML/Child.html#method-i-replace_with","( child )","<p>Replaces this object with another object.  Basically, calls Parent.replace_child\n<p>Returns &mdash; self\n\n"],["reset","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-reset","()",""],["reset","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-reset","()",""],["reset","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-reset","()",""],["reset","REXML::Validation::State","REXML/Validation/State.html#method-i-reset","()",""],["reset","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-reset","()",""],["rewind","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-rewind","()",""],["rewind","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-rewind","()",""],["root","REXML::Document","REXML/Document.html#method-i-root","()","<p>Returns the root element of the document, if it exists, otherwise <code>nil</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;root&gt;&lt;/root&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["root","REXML::Element","REXML/Element.html#method-i-root","()","<p>Returns the most distant <em>element</em> (not document) ancestor of the element:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["root","REXML::Light::Node","REXML/Light/Node.html#method-i-root","()",""],["root_node","REXML::Element","REXML/Element.html#method-i-root_node","()","<p>Returns the most distant ancestor of <code>self</code>.\n<p>When the element is part of a document, returns the root node …\n"],["round","REXML::Functions","REXML/Functions.html#method-c-round","( number )",""],["send","REXML::Functions","REXML/Functions.html#method-c-send","(name, *args)",""],["single?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-single-3F","()",""],["singleton_method_added","REXML::Functions","REXML/Functions.html#method-c-singleton_method_added","(name)",""],["size","REXML::Attributes","REXML/Attributes.html#method-i-size","()",""],["size","REXML::Elements","REXML/Elements.html#method-i-size","()","<p>Returns the count of Element children:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;sean&lt;b/&gt;elliott&lt;b/&gt;russell&lt;b/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["size","REXML::Light::Node","REXML/Light/Node.html#method-i-size","()",""],["size","REXML::Parent","REXML/Parent.html#method-i-size","()","<p>@return the number of children of this parent\n"],["source","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-source","()",""],["stand_alone?","REXML::Document","REXML/Document.html#method-i-stand_alone-3F","()","<p>Returns the XMLDecl standalone value of the document as a string, if it has been set, otherwise the default …\n"],["start_document","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_document","()",""],["start_element","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_element","(uri, localname, qname, attributes)",""],["start_element?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-start_element-3F","()","<p>Content: [ String tag_name, Hash attributes ]\n"],["start_prefix_mapping","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_prefix_mapping","(prefix, uri)",""],["starts_with","REXML::Functions","REXML/Functions.html#method-c-starts_with","( string, test )","<p>Fixed by Mike Stok\n"],["stream=","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-stream-3D","( source )",""],["string","REXML::Functions","REXML/Functions.html#method-c-string","( object=@@context[:node] )","<p>A node-set is converted to a string by returning the string-value of the node in the node-set that is …\n"],["string_length","REXML::Functions","REXML/Functions.html#method-c-string_length","( string )","<p>UNTESTED\n"],["string_value","REXML::Functions","REXML/Functions.html#method-c-string_value","( o )","<p>A node-set is converted to a string by returning the concatenation of the string-value of each of the …\n"],["substring","REXML::Functions","REXML/Functions.html#method-c-substring","( string, start, length=nil )","<p>Take equal portions of Mike Stok and Sean Russell; mix vigorously, and pour into a tall, chilled glass. …\n"],["substring_after","REXML::Functions","REXML/Functions.html#method-c-substring_after","( string, test )","<p>Kouhei fixed this too\n"],["substring_before","REXML::Functions","REXML/Functions.html#method-c-substring_before","( string, test )","<p>Kouhei fixed this\n"],["sum","REXML::Functions","REXML/Functions.html#method-c-sum","( nodes )",""],["system","REXML::DocType","REXML/DocType.html#method-i-system","()","<p>This method retrieves the system identifier identifying the document&#39;s DTD\n<p>Method contributed by  …\n"],["tag_end","REXML::StreamListener","REXML/StreamListener.html#method-i-tag_end","(name)","<p>Called when the end tag is reached.  In the case of &lt;tag/&gt;, tag_end will be called immediately …\n"],["tag_start","REXML::StreamListener","REXML/StreamListener.html#method-i-tag_start","(name, attrs)","<p>Called when a tag is encountered. @p name the tag name @p attrs an array of arrays of attribute/value …\n"],["text","REXML::Element","REXML/Element.html#method-i-text","( path = nil )","<p>Returns the text string from the first text node child in a specified element, if it exists, <code>nil</code> otherwise. …\n"],["text","REXML::Functions","REXML/Functions.html#method-c-text","( )",""],["text","REXML::StreamListener","REXML/StreamListener.html#method-i-text","(text)","<p>Called when text is encountered in the document @p text the text content.\n"],["text=","REXML::Element","REXML/Element.html#method-i-text-3D","( text )","<p>Adds, replaces, or removes the first text node child in the element.\n<p>With string argument <code>string</code>, creates …\n"],["text=","REXML::Light::Node","REXML/Light/Node.html#method-i-text-3D","( foo )",""],["text?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-text-3F","()","<p>Content: [ String raw_text, String unnormalized_text ]\n"],["texts","REXML::Element","REXML/Element.html#method-i-texts","()","<p>Returns a frozen array of the REXML::Text children of the element:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">xml_string</span> = <span class=\"ruby-string\">&#39;&lt;root&gt;&lt;a/&gt;text&lt;b/&gt;more&lt;c/&gt;&lt;/root&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_a","REXML::Attributes","REXML/Attributes.html#method-i-to_a","()","<p>Returns an array of REXML::Attribute objects representing the attributes:\n\n<pre>xml_string = &lt;&lt;-EOT\n  &lt;root ...</pre>\n"],["to_a","REXML::Elements","REXML/Elements.html#method-i-to_a","( xpath=nil )","<p>Returns an array of element children (not including non-element children).\n<p>With no argument, returns an …\n"],["to_a","REXML::Parent","REXML/Parent.html#method-i-to_a","()",""],["to_s","REXML::Attribute","REXML/Attribute.html#method-i-to_s","()","<p>Returns the attribute value, with entities replaced\n"],["to_s","REXML::CData","REXML/CData.html#method-i-to_s","()","<p>Returns the content of this CData object\n<p><em>Examples</em>\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">c</span> = <span class=\"ruby-constant\">CData</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;Some text&quot;</span> )\n<span class=\"ruby-identifier\">c</span>.<span class=\"ruby-identifier\">to_s</span>        <span class=\"ruby-comment\"># -&gt; &quot;Some ...</span>\n</pre>\n"],["to_s","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-i-to_s","()",""],["to_s","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-i-to_s","()",""],["to_s","REXML::Declaration","REXML/Declaration.html#method-i-to_s","()",""],["to_s","REXML::Entity","REXML/Entity.html#method-i-to_s","()","<p>Returns this entity as a string.  See write().\n"],["to_s","REXML::ExternalEntity","REXML/ExternalEntity.html#method-i-to_s","()",""],["to_s","REXML::Light::Node","REXML/Light/Node.html#method-i-to_s","()",""],["to_s","REXML::Node","REXML/Node.html#method-i-to_s","(indent=nil)","<p>indent &mdash; <strong>DEPRECATED</strong> This parameter is now ignored.  See the formatters in the REXML::Formatters package …\n\n"],["to_s","REXML::NotationDecl","REXML/NotationDecl.html#method-i-to_s","()",""],["to_s","REXML::Output","REXML/Output.html#method-i-to_s","()",""],["to_s","REXML::ParseException","REXML/ParseException.html#method-i-to_s","()",""],["to_s","REXML::Text","REXML/Text.html#method-i-to_s","()","<p>Returns the string value of this text node.  This string is always escaped, meaning that it is a valid …\n"],["to_s","REXML::Validation::Event","REXML/Validation/Event.html#method-i-to_s","()",""],["to_s","REXML::Validation::Ref","REXML/Validation/Ref.html#method-i-to_s","()",""],["to_s","REXML::Validation::State","REXML/Validation/State.html#method-i-to_s","()",""],["to_string","REXML::Attribute","REXML/Attribute.html#method-i-to_string","()","<p>Returns this attribute out as XML source, expanding the name\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> = <span class=\"ruby-constant\">Attribute</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;x&quot;</span>, <span class=\"ruby-string\">&quot;y&quot;</span> )\n<span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">to_string</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["translate","REXML::Functions","REXML/Functions.html#method-c-translate","( string, tr1, tr2 )","<p>This is entirely Mike Stok&#39;s beast\n"],["true","REXML::Functions","REXML/Functions.html#method-c-true","( )","<p>UNTESTED\n"],["unnormalize","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-unnormalize","( string, entities=nil, filter=nil )","<p>Unescapes all possible entities\n"],["unnormalized","REXML::Entity","REXML/Entity.html#method-i-unnormalized","()","<p>Evaluates to the unnormalized value of this entity; that is, replacing all entities – both %ent; and …\n"],["unshift","REXML::Parent","REXML/Parent.html#method-i-unshift","( object )",""],["unshift","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-unshift","(token)","<p>Push an event back on the head of the stream.  This method has (theoretically) infinite depth.\n"],["unshift","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-unshift","(token)",""],["validate","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-validate","( event )",""],["value","REXML::Attribute","REXML/Attribute.html#method-i-value","()","<p>Returns the UNNORMALIZED value of this attribute.  That is, entities have been expanded to their values …\n"],["value","REXML::CData","REXML/CData.html#method-i-value","()",""],["value","REXML::Entity","REXML/Entity.html#method-i-value","()","<p>Returns the value of this entity.  At the moment, only internal entities are processed.  If the value …\n"],["value","REXML::Text","REXML/Text.html#method-i-value","()","<p>Returns the string value of this text.  This is the text without entities, as it might be used programmatically, …\n"],["value=","REXML::Text","REXML/Text.html#method-i-value-3D","( val )","<p>Sets the contents of this text node.  This expects the text to be unnormalized.  It returns self.\n\n<pre>e = ...</pre>\n"],["variables","REXML::Functions","REXML/Functions.html#method-c-variables","()",""],["variables=","REXML::Functions","REXML/Functions.html#method-c-variables-3D","(x)",""],["variables=","REXML::XPathParser","REXML/XPathParser.html#method-i-variables-3D","( vars={} )",""],["version","REXML::Document","REXML/Document.html#method-i-version","()","<p>Returns the XMLDecl version of this document as a string, if it has been set, otherwise the default version: …\n"],["whitespace","REXML::Element","REXML/Element.html#method-i-whitespace","()","<p>Returns <code>true</code> if whitespace is respected for this element, <code>false</code> otherwise.\n<p>See Element Context.\n<p>The evaluation …\n"],["wrap","REXML::Text","REXML/Text.html#method-i-wrap","(string, width, addnewline=false)",""],["write","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-write","(out, indent=-1)","<p>Write out exactly what we got in.\n"],["write","REXML::Attribute","REXML/Attribute.html#method-i-write","( output, indent=-1 )","<p>Writes this attribute (EG, puts &#39;key=“value”&#39; to the output)\n"],["write","REXML::CData","REXML/CData.html#method-i-write","( output=$stdout, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See the rexml/formatters package\n<p>Generates XML output of this object\n"],["write","REXML::Comment","REXML/Comment.html#method-i-write","( output, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See REXML::Formatters\n<p>output &mdash; Where to write the string\n"],["write","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-i-write","( output, indent )",""],["write","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-i-write","( output, indent )",""],["write","REXML::Declaration","REXML/Declaration.html#method-i-write","( output, indent )","<p>DEPRECATED\n<p>See REXML::Formatters\n"],["write","REXML::DocType","REXML/DocType.html#method-i-write","( output, indent=0, transitive=false, ie_hack=false )","<p>output &mdash; Where to write the string\n<p>indent &mdash; An integer.  If -1, no indentation will be used; otherwise, the …\n"],["write","REXML::Document","REXML/Document.html#method-i-write","(*arguments)","<p>Write the XML tree out, optionally with indent.  This writes out the entire XML document, including  …\n"],["write","REXML::Element","REXML/Element.html#method-i-write","(output=$stdout, indent=-1, transitive=false, ie_hack=false)","<p>DEPRECATED\n<p>See REXML::Formatters\n<p>Writes out this element, and recursively, all children.\n"],["write","REXML::Entity","REXML/Entity.html#method-i-write","(out, indent=-1)","<p>Write out a fully formed, correct entity definition (assuming the Entity object itself is valid.)\n<p>out … &mdash; "],["write","REXML::ExternalEntity","REXML/ExternalEntity.html#method-i-write","( output, indent )",""],["write","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write","( node, output )","<p>Writes the node to some output.\n<p>node &mdash; The node to write\n<p>output &mdash; A class implementing <code>&amp;lt;&amp;lt;</code>.   …\n"],["write","REXML::Instruction","REXML/Instruction.html#method-i-write","(writer, indent=-1, transitive=false, ie_hack=false)","<p>DEPRECATED\n<p>See the rexml/formatters package\n"],["write","REXML::NotationDecl","REXML/NotationDecl.html#method-i-write","( output, indent=-1 )",""],["write","REXML::ReferenceWriter","REXML/ReferenceWriter.html#method-i-write","(output)",""],["write","REXML::Text","REXML/Text.html#method-i-write","( writer, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See REXML::Formatters\n"],["write","REXML::XMLDecl","REXML/XMLDecl.html#method-i-write","(writer, indent=-1, transitive=false, ie_hack=false)","<p>indent &mdash; Ignored.  There must be no whitespace before an XML declaration\n<p>transitive &mdash; Ignored\n<p>ie_hack &mdash; Ignored …\n"],["write_cdata","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_cdata","( node, output )",""],["write_cdata","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_cdata","( node, output)",""],["write_comment","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_comment","( node, output )",""],["write_comment","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_comment","( node, output)",""],["write_document","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_document","( node, output )",""],["write_document","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_document","( node, output )",""],["write_element","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_element","( node, output )",""],["write_element","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_element","(node, output)",""],["write_element","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-i-write_element","( node, output )",""],["write_instruction","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_instruction","( node, output )",""],["write_text","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_text","( node, output )",""],["write_text","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_text","( node, output )",""],["write_text","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-i-write_text","( node, output )",""],["write_with_substitution","REXML::Text","REXML/Text.html#method-i-write_with_substitution","(out, input)","<p>Writes out text, substituting special characters beforehand. <code>out</code> A String, IO, or any other object supporting …\n"],["xml_decl","REXML::Document","REXML/Document.html#method-i-xml_decl","()","<p>Returns the XMLDecl object for the document, if it exists, otherwise the default XMLDecl object:\n\n<pre>d = REXML::Document.new(&#39;&lt;?xml ...</pre>\n"],["xmldecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-xmldecl","(version, encoding, standalone)","<p>Called when an XML PI is encountered in the document. EG: &lt;?xml version=“1.0” encoding=“utf”?&gt; …\n"],["xmldecl","REXML::StreamListener","REXML/StreamListener.html#method-i-xmldecl","(version, encoding, standalone)","<p>Called when an XML PI is encountered in the document. EG: &lt;?xml version=“1.0” encoding=“utf”?&gt; …\n"],["xmldecl","REXML::XMLDecl","REXML/XMLDecl.html#method-i-xmldecl","(version, encoding, standalone)",""],["xmldecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-xmldecl-3F","()","<p>Content: [ String version, String encoding, String standalone ]\n"],["xpath","REXML::Attribute","REXML/Attribute.html#method-i-xpath","()",""],["xpath","REXML::Element","REXML/Element.html#method-i-xpath","()","<p>Returns the string xpath to the element relative to the most distant parent:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">REXML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["xpath","REXML::Text","REXML/Text.html#method-i-xpath","()","<p>FIXME This probably won&#39;t work properly\n"],["LICENSE","","LICENSE_txt.html","","<p>Copyright (C) 1993-2013 Yukihiro Matsumoto. All rights reserved.\n<p>Redistribution and use in source and …\n"],["NEWS","","NEWS_md.html","","<p>News\n<p>3.2.8 - 2024-05-16 {#version-3-2-8}\n<p>Fixes\n"],["README","","README_md.html","","<p>REXML\n<p>REXML was inspired by the Electric XML library for Java, which features an easy-to-use API, small …\n"],["context","","doc/rexml/context_rdoc.html","","<p>Element Context\n<p>Notes:\n<p>All code on this page presupposes that the following has been executed:\n"],["child","","doc/rexml/tasks/rdoc/child_rdoc.html","","<p>Class Child\n<p>Class Child includes module Node; see Tasks for Node.\n<p>Tasks on this page:\n"],["document","","doc/rexml/tasks/rdoc/document_rdoc.html","","<p>Class Document\n<p>Class Document has methods from its superclasses and included modules; see:\n<p>Tasks for Element …\n"],["element","","doc/rexml/tasks/rdoc/element_rdoc.html","","<p>Class Element\n<p>Class Element has methods from its superclasses and included modules; see:\n<p>Tasks for Parent …\n"],["node","","doc/rexml/tasks/rdoc/node_rdoc.html","","<p>Module Node\n<p>Tasks on this page:\n<p>Siblings\n"],["parent","","doc/rexml/tasks/rdoc/parent_rdoc.html","","<p>Class Parent\n<p>Class Parent has methods from its superclasses and included modules; see:\n<p>Tasks for Child …\n"],["child_toc","","doc/rexml/tasks/tocs/child_toc_rdoc.html","","<p>Tasks on this page:\n<p>Relationships\n<p>Task: Set the Parent\n"],["document_toc","","doc/rexml/tasks/tocs/document_toc_rdoc.html","","<p>Tasks on this page:\n<p>New Document\n<p>Task: Create an Empty Document\n"],["element_toc","","doc/rexml/tasks/tocs/element_toc_rdoc.html","","<p>Tasks on this page:\n<p>New Element\n<p>Task: Create a Default Element\n"],["master_toc","","doc/rexml/tasks/tocs/master_toc_rdoc.html","","<p>Tasks\n<p>Child\n<p>Relationships\n"],["node_toc","","doc/rexml/tasks/tocs/node_toc_rdoc.html","","<p>Tasks on this page:\n<p>Siblings\n<p>Task: Find Previous Sibling\n"],["parent_toc","","doc/rexml/tasks/tocs/parent_toc_rdoc.html","","<p>Tasks on this page:\n<p>Queries\n<p>Task: Get the Count of Children\n"],["tutorial","","doc/rexml/tutorial_rdoc.html","","<p>REXML Tutorial\n<p>Why REXML?\n<p>Ruby&#39;s REXML library is part of the Ruby distribution, so using it requires …\n"]]}}